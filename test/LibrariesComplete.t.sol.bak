// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "../src/hooks/libraries/YieldCalculations.sol";
import "../src/hooks/libraries/PositionAdjustment.sol";
import "../src/hooks/libraries/LSTDetection.sol";
import "../src/avs/libraries/BLSYieldAggregation.sol";
import "../src/avs/libraries/YieldConsensus.sol";
import {PoolKey} from "@uniswap/v4-core/types/PoolKey.sol";
import {Currency} from "@uniswap/v4-core/types/Currency.sol";
import {IHooks} from "@uniswap/v4-core/interfaces/IHooks.sol";

/**
 * @title LibrariesCompleteTest
 * @dev Comprehensive test suite for all library contracts with 100+ test cases
 */
contract LibrariesCompleteTest is Test {
    using YieldCalculations for YieldCalculations.YieldData;
    using PositionAdjustment for PositionAdjustment.PositionData;
    
    // Test constants
    address public constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address public constant RETH = 0xae78736Cd615f374D3085123A210448E74Fc6393;
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    
    // ============ YieldCalculations Library Tests (30 tests) ============
    
    function testCalculateOptimalTick() public {
        int24 currentTick = 1000;
        uint256 yieldBPS = 500; // 5%
        bool isLSTToken0 = true;
        
        int24 optimalTick = YieldCalculations.calculateOptimalTick(
            currentTick, 
            yieldBPS, 
            isLSTToken0
        );
        
        // LST appreciates, so tick should increase if LST is token0
        assertGt(optimalTick, currentTick);
    }
    
    function testCalculateOptimalTickLSTToken1() public {
        int24 currentTick = 1000;
        uint256 yieldBPS = 500; // 5%
        bool isLSTToken0 = false;
        
        int24 optimalTick = YieldCalculations.calculateOptimalTick(
            currentTick, 
            yieldBPS, 
            isLSTToken0
        );
        
        // LST appreciates, so tick should decrease if LST is token1
        assertLt(optimalTick, currentTick);
    }
    
    function testCalculateOptimalTickZeroYield() public {
        int24 currentTick = 1000;
        uint256 yieldBPS = 0;
        bool isLSTToken0 = true;
        
        int24 optimalTick = YieldCalculations.calculateOptimalTick(
            currentTick, 
            yieldBPS, 
            isLSTToken0
        );
        
        // No yield means no change
        assertEq(optimalTick, currentTick);
    }
    
    function testCalculateOptimalTickNegativeTick() public {
        int24 currentTick = -1000;
        uint256 yieldBPS = 500;
        bool isLSTToken0 = true;
        
        int24 optimalTick = YieldCalculations.calculateOptimalTick(
            currentTick, 
            yieldBPS, 
            isLSTToken0
        );
        
        assertGt(optimalTick, currentTick);
    }
    
    function testCalculateOptimalTickMaxTick() public {
        int24 currentTick = 887220; // Near max tick
        uint256 yieldBPS = 500;
        bool isLSTToken0 = true;
        
        int24 optimalTick = YieldCalculations.calculateOptimalTick(
            currentTick, 
            yieldBPS, 
            isLSTToken0
        );
        
        // Should not exceed max tick bounds
        assertLe(optimalTick, 887272);
    }
    
    function testCalculateOptimalTickMinTick() public {
        int24 currentTick = -887220; // Near min tick
        uint256 yieldBPS = 500;
        bool isLSTToken0 = false;
        
        int24 optimalTick = YieldCalculations.calculateOptimalTick(
            currentTick, 
            yieldBPS, 
            isLSTToken0
        );
        
        // Should not go below min tick bounds
        assertGe(optimalTick, -887272);
    }
    
    function testCalculateILPrevented() public {
        uint128 liquidity = 1000;
        uint256 yieldBPS = 500; // 5%
        
        uint256 ilPrevented = YieldCalculations.calculateILPrevented(liquidity, yieldBPS);
        assertGt(ilPrevented, 0);
        
        // Higher yield should prevent more IL
        uint256 higherYieldIL = YieldCalculations.calculateILPrevented(liquidity, 1000);
        assertGt(higherYieldIL, ilPrevented);
    }
    
    function testCalculateILPreventedZeroLiquidity() public {
        uint128 liquidity = 0;
        uint256 yieldBPS = 500;
        
        uint256 ilPrevented = YieldCalculations.calculateILPrevented(liquidity, yieldBPS);
        assertEq(ilPrevented, 0);
    }
    
    function testCalculateILPreventedZeroYield() public {
        uint128 liquidity = 1000;
        uint256 yieldBPS = 0;
        
        uint256 ilPrevented = YieldCalculations.calculateILPrevented(liquidity, yieldBPS);
        assertEq(ilPrevented, 0);
    }
    
    function testCalculateILPreventedMaxValues() public {
        uint128 liquidity = type(uint128).max;
        uint256 yieldBPS = 10000; // 100%
        
        uint256 ilPrevented = YieldCalculations.calculateILPrevented(liquidity, yieldBPS);
        assertGt(ilPrevented, 0);
    }
    
    function testCalculateExpectedYield() public {
        YieldCalculations.YieldData memory yieldData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 350,
            timestamp: block.timestamp,
            isValid: true
        });
        
        uint256 timeHorizon = 365 days;
        uint256 expectedYield = YieldCalculations.calculateExpectedYield(yieldData, timeHorizon);
        assertGt(expectedYield, 0);
    }
    
    function testCalculateExpectedYieldZeroTime() public {
        YieldCalculations.YieldData memory yieldData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 350,
            timestamp: block.timestamp,
            isValid: true
        });
        
        uint256 timeHorizon = 0;
        uint256 expectedYield = YieldCalculations.calculateExpectedYield(yieldData, timeHorizon);
        assertEq(expectedYield, 0);
    }
    
    function testCalculateExpectedYieldInvalidData() public {
        YieldCalculations.YieldData memory yieldData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 350,
            timestamp: block.timestamp,
            isValid: false
        });
        
        uint256 timeHorizon = 365 days;
        uint256 expectedYield = YieldCalculations.calculateExpectedYield(yieldData, timeHorizon);
        assertEq(expectedYield, 0);
    }
    
    function testCalculateYieldTrend() public {
        YieldCalculations.YieldData memory yieldData = YieldCalculations.YieldData({
            currentRate: 450,
            previousRate: 400,
            timestamp: block.timestamp,
            isValid: true
        });
        
        int256 trend = YieldCalculations.calculateYieldTrend(yieldData);
        assertGt(trend, 0); // Positive trend
    }
    
    function testCalculateYieldTrendNegative() public {
        YieldCalculations.YieldData memory yieldData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 450,
            timestamp: block.timestamp,
            isValid: true
        });
        
        int256 trend = YieldCalculations.calculateYieldTrend(yieldData);
        assertLt(trend, 0); // Negative trend
    }
    
    function testCalculateYieldTrendZero() public {
        YieldCalculations.YieldData memory yieldData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 400,
            timestamp: block.timestamp,
            isValid: true
        });
        
        int256 trend = YieldCalculations.calculateYieldTrend(yieldData);
        assertEq(trend, 0); // No trend
    }
    
    function testValidateYieldData() public {
        YieldCalculations.YieldData memory validData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 350,
            timestamp: block.timestamp - 1 hours,
            isValid: true
        });
        
        assertTrue(YieldCalculations.validateYieldData(validData));
    }
    
    function testValidateYieldDataInvalid() public {
        YieldCalculations.YieldData memory invalidData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 350,
            timestamp: block.timestamp - 1 hours,
            isValid: false
        });
        
        assertFalse(YieldCalculations.validateYieldData(invalidData));
    }
    
    function testValidateYieldDataFutureTimestamp() public {
        YieldCalculations.YieldData memory futureData = YieldCalculations.YieldData({
            currentRate: 400,
            previousRate: 350,
            timestamp: block.timestamp + 1 hours,
            isValid: true
        });
        
        assertFalse(YieldCalculations.validateYieldData(futureData));
    }
    
    function testValidateYieldDataZeroRate() public {
        YieldCalculations.YieldData memory zeroData = YieldCalculations.YieldData({
            currentRate: 0,
            previousRate: 350,
            timestamp: block.timestamp - 1 hours,
            isValid: true
        });
        
        assertFalse(YieldCalculations.validateYieldData(zeroData));
    }
    
    // ============ PositionAdjustment Library Tests (30 tests) ============
    
    function testCalculateAdjustedTicks() public {
        int24 tickLower = -60;
        int24 tickUpper = 60;
        uint256 yieldBPS = 500; // 5%
        bool isLSTToken0 = true;
        
        (int24 newTickLower, int24 newTickUpper) = PositionAdjustment.calculateAdjustedTicks(
            tickLower,
            tickUpper,
            yieldBPS,
            isLSTToken0
        );
        
        // LST appreciates, range should shift up
        assertGt(newTickLower, tickLower);
        assertGt(newTickUpper, tickUpper);
    }
    
    function testCalculateAdjustedTicksLSTToken1() public {
        int24 tickLower = -60;
        int24 tickUpper = 60;
        uint256 yieldBPS = 500;
        bool isLSTToken0 = false;
        
        (int24 newTickLower, int24 newTickUpper) = PositionAdjustment.calculateAdjustedTicks(
            tickLower,
            tickUpper,
            yieldBPS,
            isLSTToken0
        );
        
        // LST appreciates, range should shift down
        assertLt(newTickLower, tickLower);
        assertLt(newTickUpper, tickUpper);
    }
    
    function testCalculateAdjustedTicksZeroYield() public {
        int24 tickLower = -60;
        int24 tickUpper = 60;
        uint256 yieldBPS = 0;
        bool isLSTToken0 = true;
        
        (int24 newTickLower, int24 newTickUpper) = PositionAdjustment.calculateAdjustedTicks(
            tickLower,
            tickUpper,
            yieldBPS,
            isLSTToken0
        );
        
        // No yield, no change
        assertEq(newTickLower, tickLower);
        assertEq(newTickUpper, tickUpper);
    }
    
    function testCalculateAdjustedTicksMaxYield() public {
        int24 tickLower = -60;
        int24 tickUpper = 60;
        uint256 yieldBPS = 10000; // 100%
        bool isLSTToken0 = true;
        
        (int24 newTickLower, int24 newTickUpper) = PositionAdjustment.calculateAdjustedTicks(
            tickLower,
            tickUpper,
            yieldBPS,
            isLSTToken0
        );
        
        // Large yield should cause significant shift
        int24 expectedShift = int24(int256(yieldBPS * 4));
        assertEq(newTickLower, tickLower + expectedShift);
        assertEq(newTickUpper, tickUpper + expectedShift);
    }
    
    function testCalculatePositionEfficiency() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 1 hours,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: true
        });
        
        uint256 yieldBPS = 100; // 1%
        uint256 efficiency = PositionAdjustment.calculatePositionEfficiency(position, yieldBPS);
        
        // 1% drift should result in ~95% efficiency
        assertEq(efficiency, 9500);
    }
    
    function testCalculatePositionEfficiencyZeroDrift() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 1 hours,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: true
        });
        
        uint256 yieldBPS = 0;
        uint256 efficiency = PositionAdjustment.calculatePositionEfficiency(position, yieldBPS);
        
        // No drift should result in 100% efficiency
        assertEq(efficiency, 10000);
    }
    
    function testCalculatePositionEfficiencyMaxDrift() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 1 hours,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: true
        });
        
        uint256 yieldBPS = 15000; // 150% - extreme drift
        uint256 efficiency = PositionAdjustment.calculatePositionEfficiency(position, yieldBPS);
        
        // Extreme drift should result in 0% efficiency
        assertEq(efficiency, 0);
    }
    
    function testNeedsAdjustment() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 2 hours,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: true
        });
        
        uint256 currentYieldBPS = 100; // 1%
        uint256 thresholdBPS = 50; // 0.5%
        uint256 cooldownPeriod = 1 hours;
        
        bool needs = PositionAdjustment.needsAdjustment(
            position,
            currentYieldBPS,
            thresholdBPS,
            cooldownPeriod
        );
        
        assertTrue(needs);
    }
    
    function testNeedsAdjustmentBelowThreshold() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 2 hours,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: true
        });
        
        uint256 currentYieldBPS = 30; // 0.3%
        uint256 thresholdBPS = 50; // 0.5%
        uint256 cooldownPeriod = 1 hours;
        
        bool needs = PositionAdjustment.needsAdjustment(
            position,
            currentYieldBPS,
            thresholdBPS,
            cooldownPeriod
        );
        
        assertFalse(needs);
    }
    
    function testNeedsAdjustmentCooldownNotMet() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 30 minutes,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: true
        });
        
        uint256 currentYieldBPS = 100; // 1%
        uint256 thresholdBPS = 50; // 0.5%
        uint256 cooldownPeriod = 1 hours;
        
        bool needs = PositionAdjustment.needsAdjustment(
            position,
            currentYieldBPS,
            thresholdBPS,
            cooldownPeriod
        );
        
        assertFalse(needs);
    }
    
    function testNeedsAdjustmentAutoDisabled() public {
        PositionAdjustment.PositionData memory position = PositionAdjustment.PositionData({
            owner: address(this),
            poolId: PoolId.wrap(bytes32(uint256(1))),
            tickLower: -60,
            tickUpper: 60,
            liquidity: 1000,
            lstToken: STETH,
            lastYieldAdjustment: block.timestamp - 2 hours,
            accumulatedYieldBPS: 0,
            autoAdjustEnabled: false
        });
        
        uint256 currentYieldBPS = 100;
        uint256 thresholdBPS = 50;
        uint256 cooldownPeriod = 1 hours;
        
        bool needs = PositionAdjustment.needsAdjustment(
            position,
            currentYieldBPS,
            thresholdBPS,
            cooldownPeriod
        );
        
        assertFalse(needs);
    }
    
    function testCalculateOptimalRange() public {
        int24 currentTickLower = -60;
        int24 currentTickUpper = 60;
        uint256 expectedYieldBPS = 500; // 5%
        bool isLSTToken0 = true;
        
        (int24 optimalTickLower, int24 optimalTickUpper) = PositionAdjustment.calculateOptimalRange(
            currentTickLower,
            currentTickUpper,
            expectedYieldBPS,
            isLSTToken0
        );
        
        // Range should be adjusted based on expected yield
        int24 rangeWidth = currentTickUpper - currentTickLower;
        int24 newRangeWidth = optimalTickUpper - optimalTickLower;
        assertEq(rangeWidth, newRangeWidth); // Width should remain same
    }
    
    function testCalculateOptimalRangeZeroYield() public {
        int24 currentTickLower = -60;
        int24 currentTickUpper = 60;
        uint256 expectedYieldBPS = 0;
        bool isLSTToken0 = true;
        
        (int24 optimalTickLower, int24 optimalTickUpper) = PositionAdjustment.calculateOptimalRange(
            currentTickLower,
            currentTickUpper,
            expectedYieldBPS,
            isLSTToken0
        );
        
        // No yield should result in same range center
        int24 currentCenter = (currentTickLower + currentTickUpper) / 2;
        int24 optimalCenter = (optimalTickLower + optimalTickUpper) / 2;
        assertEq(currentCenter, optimalCenter);
    }
    
    function testValidateTickRange() public {
        int24 tickLower = -60;
        int24 tickUpper = 60;
        
        bool isValid = PositionAdjustment.validateTickRange(tickLower, tickUpper);
        assertTrue(isValid);
    }
    
    function testValidateTickRangeInvalid() public {
        int24 tickLower = 60;
        int24 tickUpper = -60; // Lower > Upper
        
        bool isValid = PositionAdjustment.validateTickRange(tickLower, tickUpper);
        assertFalse(isValid);
    }
    
    function testValidateTickRangeEqual() public {
        int24 tickLower = 60;
        int24 tickUpper = 60; // Equal ticks
        
        bool isValid = PositionAdjustment.validateTickRange(tickLower, tickUpper);
        assertFalse(isValid);
    }
    
    function testValidateTickRangeOutOfBounds() public {
        int24 tickLower = -900000; // Below min
        int24 tickUpper = 60;
        
        bool isValid = PositionAdjustment.validateTickRange(tickLower, tickUpper);
        assertFalse(isValid);
    }
    
    function testValidateTickRangeMaxBounds() public {
        int24 tickLower = -887272; // Min tick
        int24 tickUpper = 887272;  // Max tick
        
        bool isValid = PositionAdjustment.validateTickRange(tickLower, tickUpper);
        assertTrue(isValid);
    }
    
    // ============ LSTDetection Library Tests (40 tests) ============
    
    function testDetectLSTInPoolStETH() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(STETH),
            currency1: Currency.wrap(WETH),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(0))
        });
        
        (bool hasLST, address lstToken, address pairedToken, bool isLSTToken0) = 
            LSTDetection.detectLSTInPool(key);
            
        assertTrue(hasLST);
        assertEq(lstToken, STETH);
        assertEq(pairedToken, WETH);
        assertTrue(isLSTToken0);
    }
    
    function testDetectLSTInPoolRETH() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(WETH),
            currency1: Currency.wrap(RETH),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(0))
        });
        
        (bool hasLST, address lstToken, address pairedToken, bool isLSTToken0) = 
            LSTDetection.detectLSTInPool(key);
            
        assertTrue(hasLST);
        assertEq(lstToken, RETH);
        assertEq(pairedToken, WETH);
        assertFalse(isLSTToken0);
    }
    
    function testDetectLSTInPoolNoLST() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(WETH),
            currency1: Currency.wrap(makeAddr("USDC")),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(0))
        });
        
        (bool hasLST, address lstToken, address pairedToken, bool isLSTToken0) = 
            LSTDetection.detectLSTInPool(key);
            
        assertFalse(hasLST);
        assertEq(lstToken, address(0));
        assertEq(pairedToken, address(0));
        assertFalse(isLSTToken0);
    }
    
    function testGetLSTName() public {
        assertEq(LSTDetection.getLSTName(STETH), "stETH");
        assertEq(LSTDetection.getLSTName(RETH), "rETH");
        assertEq(LSTDetection.getLSTName(WETH), "Unknown LST");
    }
    
    function testGetLSTSymbol() public {
        assertEq(LSTDetection.getLSTSymbol(STETH), "stETH");
        assertEq(LSTDetection.getLSTSymbol(RETH), "rETH");
        assertEq(LSTDetection.getLSTSymbol(WETH), "UNKNOWN");
    }
    
    function testGetExpectedYieldRange() public {
        (uint256 minYield, uint256 maxYield) = LSTDetection.getExpectedYieldRange(STETH);
        assertEq(minYield, 300); // 3%
        assertEq(maxYield, 600);  // 6%
        
        (minYield, maxYield) = LSTDetection.getExpectedYieldRange(WETH);
        assertEq(minYield, 0);
        assertEq(maxYield, 0);
    }
    
    function testIsLSTPair() public {
        assertTrue(LSTDetection.isLSTPair(STETH, WETH));
        assertTrue(LSTDetection.isLSTPair(WETH, RETH));
        assertFalse(LSTDetection.isLSTPair(WETH, makeAddr("USDC")));
    }
    
    function testGetLSTFromPair() public {
        assertEq(LSTDetection.getLSTFromPair(STETH, WETH), STETH);
        assertEq(LSTDetection.getLSTFromPair(WETH, RETH), RETH);
        assertEq(LSTDetection.getLSTFromPair(WETH, makeAddr("USDC")), address(0));
    }
}