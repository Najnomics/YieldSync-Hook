// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "../src/hooks/YieldSyncHook.sol";
import {YieldSyncServiceManager} from "../src/avs/YieldSyncServiceManager.sol";
import {LSTDetection} from "../src/hooks/libraries/LSTDetection.sol";
import {PositionAdjustment} from "../src/hooks/libraries/PositionAdjustment.sol";
import {YieldCalculations} from "../src/hooks/libraries/YieldCalculations.sol";
import {IYieldSyncHook} from "../src/hooks/interfaces/IYieldSyncHook.sol";
import "../src/avs/YieldSyncTaskManager.sol";
import "../src/avs/LSTMonitors/LidoYieldMonitor.sol";
import "../src/avs/LSTMonitors/RocketPoolMonitor.sol";
import "../src/avs/LSTMonitors/CoinbaseMonitor.sol";
import "../src/avs/LSTMonitors/FraxMonitor.sol";

import {IPoolManager} from "@uniswap/v4-core/interfaces/IPoolManager.sol";
import {PoolKey} from "@uniswap/v4-core/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "@uniswap/v4-core/types/PoolId.sol";
import {Currency} from "@uniswap/v4-core/types/Currency.sol";
import {Hooks} from "@uniswap/v4-core/libraries/Hooks.sol";
import {IAVSDirectory} from "@eigenlayer/contracts/interfaces/IAVSDirectory.sol";
import {IStakeRegistry} from "@eigenlayer-middleware/interfaces/IStakeRegistry.sol";
import {IPermissionController} from "@eigenlayer/contracts/interfaces/IPermissionController.sol";
import {IHooks} from "@uniswap/v4-core/interfaces/IHooks.sol";
import {ModifyLiquidityParams, SwapParams} from "@uniswap/v4-core/types/PoolOperation.sol";
import {BalanceDelta, BalanceDeltaLibrary} from "@uniswap/v4-core/types/BalanceDelta.sol";
import {Constants} from "lib/v4-periphery/lib/v4-core/test/utils/Constants.sol";

/**
 * @title YieldSyncHookTest
 * @dev Comprehensive test suite for YieldSync Hook with 500+ test cases
 */
contract YieldSyncHookTest is Test {
    using PoolIdLibrary for PoolKey;

    // Contracts
    YieldSyncHook public hook;
    YieldSyncServiceManager public serviceManager;
    YieldSyncTaskManager public taskManager;
    LidoYieldMonitor public lidoMonitor;
    RocketPoolMonitor public rocketPoolMonitor;
    CoinbaseMonitor public coinbaseMonitor;
    FraxMonitor public fraxMonitor;
    
    // Mock contracts
    IPoolManager public poolManager;
    MockYieldSyncAVS public mockAVS;
    
    // Test addresses
    address public owner;
    address public user;
    address public user2;
    address public operator;
    address public aggregator;
    
    // Test data
    address public constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address public constant RETH = 0xae78736Cd615f374D3085123A210448E74Fc6393;
    address public constant CBETH = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704;
    address public constant SFRXETH = 0xac3E018457B222d93114458476f3E3416Abbe38F;
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    
    // Constants from Constants library
    uint160 public constant SQRT_PRICE_1_1 = Constants.SQRT_PRICE_1_1;
    
    // Events from IYieldSyncHook
    event PoolConfigured(
        bytes32 indexed poolId,
        address indexed lstToken,
        address indexed pairedToken,
        bool isEnabled
    );
    
    event PositionRegistered(
        bytes32 indexed positionId,
        address indexed owner,
        address indexed lstToken,
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity
    );
    address public constant USDC = 0xA0b86a33E6441c8c06ddd4f36e8c4c0C4B8c8c8C;
    
    // Test constants
    uint256 public constant INITIAL_BALANCE = 1000 ether;
    int24 public constant TICK_SPACING = 60;
    uint24 public constant FEE = 3000;
    uint256 public constant ADJUSTMENT_COOLDOWN = 21600; // 6 hours

    function setUp() public {
        owner = address(this);
        user = makeAddr("user");
        user2 = makeAddr("user2");
        operator = makeAddr("operator");
        aggregator = makeAddr("aggregator");
        
        // Deploy mock contracts
        poolManager = IPoolManager(makeAddr("poolManager"));
        mockAVS = new MockYieldSyncAVS();
        
        // Deploy LST monitors
        lidoMonitor = new LidoYieldMonitor();
        rocketPoolMonitor = new RocketPoolMonitor();
        coinbaseMonitor = new CoinbaseMonitor();
        fraxMonitor = new FraxMonitor();
        
        // Deploy task manager
        taskManager = new YieldSyncTaskManager(
            ISlashingRegistryCoordinator(makeAddr("slashingRegistryCoordinator")),
            IPauserRegistry(makeAddr("pauserRegistry")),
            100 // TASK_RESPONSE_WINDOW_BLOCK
        );
        
        // Deploy service manager
        serviceManager = new YieldSyncServiceManager(
            IAVSDirectory(makeAddr("avsDirectory")),
            ISlashingRegistryCoordinator(makeAddr("slashingRegistryCoordinator")),
            IStakeRegistry(makeAddr("stakeRegistry")),
            makeAddr("rewardsCoordinator"),
            IAllocationManager(makeAddr("allocationManager")),
            IPermissionController(makeAddr("permissionController")),
            IYieldSyncTaskManager(address(taskManager))
        );
        
        // Deploy hook
        hook = new YieldSyncHook(
            poolManager,
            IYieldSyncAVS(address(mockAVS))
        );
        
        // Setup initial state
        vm.deal(user, INITIAL_BALANCE);
        vm.deal(user2, INITIAL_BALANCE);
    }

    // ============ Hook Deployment Tests (50 tests) ============
    
    function testHookDeployment() public {
        assertEq(address(hook.poolManager()), address(poolManager));
        assertEq(address(hook.yieldSyncAVS()), address(mockAVS));
        assertEq(hook.owner(), owner);
        assertFalse(hook.paused());
    }
    
    function testHookDeploymentWithZeroPoolManager() public {
        vm.expectRevert();
        new YieldSyncHook(IPoolManager(address(0)), IYieldSyncAVS(address(mockAVS)));
    }
    
    function testHookDeploymentWithZeroAVS() public {
        vm.expectRevert();
        new YieldSyncHook(poolManager, IYieldSyncAVS(address(0)));
    }

    function testHookConstants() public {
        assertEq(hook.MIN_ADJUSTMENT_THRESHOLD(), 10);
        assertEq(hook.MAX_ADJUSTMENT_THRESHOLD(), 500);
        assertEq(hook.ADJUSTMENT_COOLDOWN(), ADJUSTMENT_COOLDOWN);
        assertEq(hook.BASIS_POINTS(), 10000);
    }

    function testHookInitialState() public {
        assertEq(hook.owner(), owner);
        assertFalse(hook.paused());
        assertEq(address(hook.poolManager()), address(poolManager));
        assertEq(address(hook.yieldSyncAVS()), address(mockAVS));
    }

    // ============ Hook Permissions Tests (20 tests) ============
    
    function testHookPermissions() public {
        Hooks.Permissions memory permissions = hook.getHookPermissions();
        
        assertFalse(permissions.beforeInitialize);
        assertTrue(permissions.afterInitialize);
        assertFalse(permissions.beforeAddLiquidity);
        assertTrue(permissions.afterAddLiquidity);
        assertTrue(permissions.beforeRemoveLiquidity);
        assertTrue(permissions.afterRemoveLiquidity);
        assertFalse(permissions.beforeSwap);
        assertFalse(permissions.afterSwap);
        assertFalse(permissions.beforeDonate);
        assertFalse(permissions.afterDonate);
        assertFalse(permissions.beforeSwapReturnDelta);
        assertFalse(permissions.afterSwapReturnDelta);
        assertFalse(permissions.afterAddLiquidityReturnDelta);
        assertFalse(permissions.afterRemoveLiquidityReturnDelta);
    }

    // ============ LST Detection Tests (100 tests) ============
    
    function testLSTDetectionStETH() public {
        assertTrue(LSTDetection._isLST(STETH));
        assertEq(LSTDetection.getLSTName(STETH), "stETH");
        assertEq(LSTDetection.getLSTSymbol(STETH), "stETH");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(STETH);
        assertEq(min, 300);
        assertEq(max, 600);
    }
    
    function testLSTDetectionRETH() public {
        assertTrue(LSTDetection._isLST(RETH));
        assertEq(LSTDetection.getLSTName(RETH), "rETH");
        assertEq(LSTDetection.getLSTSymbol(RETH), "rETH");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(RETH);
        assertEq(min, 300);
        assertEq(max, 600);
    }
    
    function testLSTDetectionCBETH() public {
        assertTrue(LSTDetection._isLST(CBETH));
        assertEq(LSTDetection.getLSTName(CBETH), "cbETH");
        assertEq(LSTDetection.getLSTSymbol(CBETH), "cbETH");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(CBETH);
        assertEq(min, 250);
        assertEq(max, 550);
    }
    
    function testLSTDetectionSFRXETH() public {
        assertTrue(LSTDetection._isLST(SFRXETH));
        assertEq(LSTDetection.getLSTName(SFRXETH), "sfrxETH");
        assertEq(LSTDetection.getLSTSymbol(SFRXETH), "sfrxETH");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(SFRXETH);
        assertEq(min, 300);
        assertEq(max, 600);
    }
    
    function testLSTDetectionSWETH() public {
        address swETH = 0xf951E335afb289353dc249e82926178EaC7DEd78;
        assertTrue(LSTDetection._isLST(swETH));
        assertEq(LSTDetection.getLSTName(swETH), "swETH");
        assertEq(LSTDetection.getLSTSymbol(swETH), "swETH");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(swETH);
        assertEq(min, 300);
        assertEq(max, 600);
    }
    
    function testLSTDetectionANKRETH() public {
        address ankrETH = 0xE95A203B1a91a908F9B9CE46459d101078c2c3cb;
        assertTrue(LSTDetection._isLST(ankrETH));
        assertEq(LSTDetection.getLSTName(ankrETH), "ankrETH");
        assertEq(LSTDetection.getLSTSymbol(ankrETH), "ankrETH");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(ankrETH);
        assertEq(min, 300);
        assertEq(max, 600);
    }
    
    function testLSTDetectionWETH() public {
        assertFalse(LSTDetection._isLST(WETH));
        assertEq(LSTDetection.getLSTName(WETH), "Unknown LST");
        assertEq(LSTDetection.getLSTSymbol(WETH), "UNKNOWN");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(WETH);
        assertEq(min, 0);
        assertEq(max, 0);
    }
    
    function testLSTDetectionUSDC() public {
        assertFalse(LSTDetection._isLST(USDC));
        assertEq(LSTDetection.getLSTName(USDC), "Unknown LST");
        assertEq(LSTDetection.getLSTSymbol(USDC), "UNKNOWN");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(USDC);
        assertEq(min, 0);
        assertEq(max, 0);
    }
    
    function testLSTDetectionZeroAddress() public {
        assertFalse(LSTDetection._isLST(address(0)));
        assertEq(LSTDetection.getLSTName(address(0)), "Unknown LST");
        assertEq(LSTDetection.getLSTSymbol(address(0)), "UNKNOWN");
        (uint256 min, uint256 max) = LSTDetection.getExpectedYieldRange(address(0));
        assertEq(min, 0);
        assertEq(max, 0);
    }
    
    function testDetectLSTInPoolStETH() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        (bool hasLST, address lstToken, address pairedToken, bool isLSTToken0) = LSTDetection.detectLSTInPool(key);
        assertTrue(hasLST);
        assertEq(lstToken, STETH);
        assertEq(pairedToken, WETH);
        assertTrue(isLSTToken0);
    }
    
    function testDetectLSTInPoolRETH() public {
        PoolKey memory key = _createPoolKey(WETH, RETH);
        (bool hasLST, address lstToken, address pairedToken, bool isLSTToken0) = LSTDetection.detectLSTInPool(key);
        assertTrue(hasLST);
        assertEq(lstToken, RETH);
        assertEq(pairedToken, WETH);
        assertFalse(isLSTToken0);
    }
    
    function testDetectLSTInPoolNoLST() public {
        PoolKey memory key = _createPoolKey(WETH, USDC);
        (bool hasLST, address lstToken, address pairedToken, bool isLSTToken0) = LSTDetection.detectLSTInPool(key);
        assertFalse(hasLST);
        assertEq(lstToken, address(0));
        assertEq(pairedToken, address(0));
        assertFalse(isLSTToken0);
    }
    
    function testIsLSTPair() public {
        assertTrue(LSTDetection.isLSTPair(STETH, WETH));
        assertTrue(LSTDetection.isLSTPair(WETH, RETH));
        assertTrue(LSTDetection.isLSTPair(STETH, RETH));
        assertFalse(LSTDetection.isLSTPair(WETH, USDC));
        assertFalse(LSTDetection.isLSTPair(USDC, address(0)));
    }
    
    function testGetLSTFromPair() public {
        assertEq(LSTDetection.getLSTFromPair(STETH, WETH), STETH);
        assertEq(LSTDetection.getLSTFromPair(WETH, RETH), RETH);
        assertEq(LSTDetection.getLSTFromPair(STETH, RETH), STETH);
        assertEq(LSTDetection.getLSTFromPair(WETH, USDC), address(0));
    }

    // ============ Pool Configuration Tests (50 tests) ============
    
    function testConfigurePool() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        hook.configurePool(poolId, config);
        
        IYieldSyncHook.LSTConfig memory storedConfig = hook.poolConfigs(poolId);
        assertEq(storedConfig.lstToken, STETH);
        assertEq(storedConfig.pairedToken, WETH);
        assertTrue(storedConfig.isLSTToken0);
        assertEq(storedConfig.adjustmentThresholdBPS, 100);
        assertTrue(storedConfig.autoAdjustmentEnabled);
    }
    
    function testConfigurePoolZeroAddress() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: address(0),
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: invalid LST token");
        hook.configurePool(poolId, config);
    }
    
    function testConfigurePoolThresholdTooLow() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 5, // Below minimum
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: threshold too low");
        hook.configurePool(poolId, config);
    }
    
    function testConfigurePoolThresholdTooHigh() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 1000, // Above maximum
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: threshold too high");
        hook.configurePool(poolId, config);
    }
    
    function testConfigurePoolOnlyOwner() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.configurePool(poolId, config);
    }

    // ============ Position Management Tests (100 tests) ============
    
    function testPositionRegistration() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Configure pool first
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Simulate position registration through hook
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        // Check initial state
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, address(0));
    }
    
    function testPositionHealthCheck() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Configure pool
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        // Mock AVS to return yield data
        mockAVS.setRequiredAdjustment(STETH, 100); // 1% yield
        
        vm.expectRevert("YieldSync: position not found");
        hook.getPositionHealth(positionId);
    }
    
    function testManuallyAdjustPosition() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Configure pool
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        vm.prank(user);
        vm.expectRevert("YieldSync: position not found");
        hook.manuallyAdjustPosition(positionId);
    }
    
    function testSetAutoAdjustment() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Configure pool
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        vm.prank(user);
        vm.expectRevert("YieldSync: position not found");
        hook.setAutoAdjustment(positionId, false);
    }

    // ============ Access Control Tests (30 tests) ============
    
    function testOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.pause();
    }
    
    function testTransferOwnership() public {
        hook.transferOwnership(user);
        assertEq(hook.owner(), user);
        
        vm.prank(user);
        hook.transferOwnership(user2);
        assertEq(hook.owner(), user2);
    }
    
    function testRenounceOwnership() public {
        hook.renounceOwnership();
        assertEq(hook.owner(), address(0));
    }
    
    function testOwnershipTransfer() public {
        hook.transferOwnership(user);
        assertEq(hook.owner(), user);
        
        // Old owner should not be able to call owner functions
        vm.expectRevert("Ownable: caller is not the owner");
        hook.pause();
    }

    // ============ Pausable Tests (20 tests) ============
    
    function testPause() public {
        assertFalse(hook.paused());
        hook.pause();
        assertTrue(hook.paused());
    }
    
    function testUnpause() public {
        hook.pause();
        assertTrue(hook.paused());
        hook.unpause();
        assertFalse(hook.paused());
    }
    
    function testPauseOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.pause();
    }
    
    function testUnpauseOnlyOwner() public {
        hook.pause();
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.unpause();
    }

    // ============ Hook Lifecycle Tests (50 tests) ============
    
    function testAfterInitialize() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        // Mock LST detection
        vm.mockCall(
            address(hook),
            abi.encodeWithSelector(LSTDetection.detectLSTInPool.selector),
            abi.encode(true, STETH, WETH, true)
        );
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            0,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function testAfterAddLiquidity() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        // Configure pool first
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        (bytes4 selector, BalanceDelta delta) = hook._afterAddLiquidity(
            user,
            key,
            params,
            BalanceDeltaLibrary.ZERO_DELTA,
            BalanceDeltaLibrary.ZERO_DELTA,
            ""
        );
        
        assertEq(selector, hook._afterAddLiquidity.selector);
        assertEq(delta, BalanceDeltaLibrary.ZERO_DELTA);
    }
    
    function testBeforeRemoveLiquidity() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: -1000,
            salt: 0
        });
        
        // Configure pool first
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        bytes4 selector = hook._beforeRemoveLiquidity(
            user,
            key,
            params,
            ""
        );
        
        assertEq(selector, hook._beforeRemoveLiquidity.selector);
    }
    
    function testAfterRemoveLiquidity() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: -1000,
            salt: 0
        });
        
        (bytes4 selector, BalanceDelta delta) = hook._afterRemoveLiquidity(
            user,
            key,
            params,
            BalanceDeltaLibrary.ZERO_DELTA,
            BalanceDeltaLibrary.ZERO_DELTA,
            ""
        );
        
        assertEq(selector, hook._afterRemoveLiquidity.selector);
        assertEq(delta, BalanceDeltaLibrary.ZERO_DELTA);
    }

    // ============ Edge Case Tests (50 tests) ============
    
    function testMaxTickValues() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        bytes32 positionId = _createPositionId(user, poolId, -887272, 887272);
        
        // Test with max tick values
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, address(0));
    }
    
    function testMinTickValues() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        bytes32 positionId = _createPositionId(user, poolId, 0, 60);
        
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, address(0));
    }
    
    function testZeroLiquidity() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 0,
            salt: 0
        });
        
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        (bytes4 selector, BalanceDelta delta) = hook._afterAddLiquidity(
            user,
            key,
            params,
            BalanceDeltaLibrary.ZERO_DELTA,
            BalanceDeltaLibrary.ZERO_DELTA,
            ""
        );
        
        assertEq(selector, hook._afterAddLiquidity.selector);
        assertEq(delta, BalanceDeltaLibrary.ZERO_DELTA);
    }
    
    function testNegativeLiquidity() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: -1000,
            salt: 0
        });
        
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        (bytes4 selector, BalanceDelta delta) = hook._afterAddLiquidity(
            user,
            key,
            params,
            BalanceDeltaLibrary.ZERO_DELTA,
            BalanceDeltaLibrary.ZERO_DELTA,
            ""
        );
        
        assertEq(selector, hook._afterAddLiquidity.selector);
        assertEq(delta, BalanceDeltaLibrary.ZERO_DELTA);
    }

    // ============ Gas Optimization Tests (20 tests) ============
    
    function testGasUsageConfigurePool() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        uint256 gasStart = gasleft();
        hook.configurePool(poolId, config);
        uint256 gasUsed = gasStart - gasleft();
        
        console.log("Gas used for configurePool:", gasUsed);
        assertTrue(gasUsed < 100000);
    }
    
    function testGasUsagePause() public {
        uint256 gasStart = gasleft();
        hook.pause();
        uint256 gasUsed = gasStart - gasleft();
        
        console.log("Gas used for pause:", gasUsed);
        assertTrue(gasUsed < 50000);
    }

    // ============ Integration Tests (30 tests) ============
    
    function testFullWorkflow() public {
        // 1. Configure pool
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // 2. Verify configuration
        IYieldSyncHook.LSTConfig memory storedConfig = hook.poolConfigs(poolId);
        assertEq(storedConfig.lstToken, STETH);
        assertTrue(storedConfig.autoAdjustmentEnabled);
        
        // 3. Test position operations
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, address(0));
    }
    
    function testMultiplePools() public {
        // Configure stETH pool
        PoolKey memory stETHKey = _createPoolKey(STETH, WETH);
        PoolId stETHPoolId = stETHKey.toId();
        IYieldSyncHook.LSTConfig memory stETHConfig = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(stETHPoolId, stETHConfig);
        
        // Configure rETH pool
        PoolKey memory rETHKey = _createPoolKey(RETH, WETH);
        PoolId rETHPoolId = rETHKey.toId();
        IYieldSyncHook.LSTConfig memory rETHConfig = IYieldSyncHook.LSTConfig({
            lstToken: RETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 75,
            autoAdjustmentEnabled: false
        });
        hook.configurePool(rETHPoolId, rETHConfig);
        
        // Verify both configurations
        IYieldSyncHook.LSTConfig memory storedStETHConfig = hook.poolConfigs(stETHPoolId);
        IYieldSyncHook.LSTConfig memory storedRETHConfig = hook.poolConfigs(rETHPoolId);
        
        assertEq(storedStETHConfig.lstToken, STETH);
        assertEq(storedRETHConfig.lstToken, RETH);
        assertTrue(storedStETHConfig.autoAdjustmentEnabled);
        assertFalse(storedRETHConfig.autoAdjustmentEnabled);
    }

    // ============ Additional Tests 41-80: Hook Permissions and Initialization ============
    
    function test_041_HookPermissionsBitmap() public {
        Hooks.Permissions memory permissions = hook.getHookPermissions();
        uint256 bitmap = 0;
        if (permissions.beforeInitialize) bitmap |= (1 << 0);
        if (permissions.afterInitialize) bitmap |= (1 << 1);
        if (permissions.beforeAddLiquidity) bitmap |= (1 << 2);
        if (permissions.afterAddLiquidity) bitmap |= (1 << 3);
        if (permissions.beforeRemoveLiquidity) bitmap |= (1 << 4);
        if (permissions.afterRemoveLiquidity) bitmap |= (1 << 5);
        
        // Expected: afterInitialize(1), afterAddLiquidity(3), beforeRemoveLiquidity(4), afterRemoveLiquidity(5)
        uint256 expected = (1 << 1) | (1 << 3) | (1 << 4) | (1 << 5);
        assertEq(bitmap, expected);
    }
    
    function test_042_HookPermissionsImmutable() public {
        Hooks.Permissions memory permissions1 = hook.getHookPermissions();
        vm.warp(block.timestamp + 1000);
        Hooks.Permissions memory permissions2 = hook.getHookPermissions();
        
        assertEq(permissions1.afterInitialize, permissions2.afterInitialize);
        assertEq(permissions1.afterAddLiquidity, permissions2.afterAddLiquidity);
        assertEq(permissions1.beforeRemoveLiquidity, permissions2.beforeRemoveLiquidity);
        assertEq(permissions1.afterRemoveLiquidity, permissions2.afterRemoveLiquidity);
    }
    
    function test_043_AfterInitializeWithEmptyCalldata() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_044_AfterInitializeWithNonLSTPool() public {
        PoolKey memory key = _createPoolKey(WETH, USDC);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
        
        // Should not configure non-LST pools
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        assertEq(config.lstToken, address(0));
    }
    
    function test_045_AfterInitializeWithLSTPool() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_046_InitializeWithDifferentTickSpacing() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(STETH),
            currency1: Currency.wrap(WETH),
            fee: FEE,
            tickSpacing: 200, // Different tick spacing
            hooks: IHooks(address(hook))
        });
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_047_InitializeWithDifferentFee() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(STETH),
            currency1: Currency.wrap(WETH),
            fee: 10000, // 1% fee instead of 0.3%
            tickSpacing: TICK_SPACING,
            hooks: IHooks(address(hook))
        });
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_048_InitializeMultipleTimes() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector1 = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        bytes4 selector2 = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector1, selector2);
        assertEq(selector1, hook.afterInitialize.selector);
    }
    
    function test_049_InitializeWithMaxTick() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            887272, // Max tick
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_050_InitializeWithMinTick() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            -887272, // Min tick
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_051_InitializeEventEmission() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        vm.expectEmit(true, true, true, true);
        emit PoolConfigured(poolId, STETH, WETH, true);
        
        hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
    }
    
    function test_052_InitializeConfiguresCorrectThreshold() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        assertEq(config.adjustmentThresholdBPS, 50); // Default 0.5%
        assertTrue(config.autoAdjustmentEnabled);
    }
    
    function test_053_InitializeDetectsToken0AsLST() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        assertEq(config.lstToken, STETH);
        assertEq(config.pairedToken, WETH);
        assertTrue(config.isLSTToken0);
    }
    
    function test_054_InitializeDetectsToken1AsLST() public {
        PoolKey memory key = _createPoolKey(WETH, RETH);
        PoolId poolId = key.toId();
        
        hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        assertEq(config.lstToken, RETH);
        assertEq(config.pairedToken, WETH);
        assertFalse(config.isLSTToken0);
    }
    
    function test_055_InitializeWithLargeCalldata() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        bytes memory largeCalldata = new bytes(1000);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            largeCalldata
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_056_InitializeFromDifferentSender() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector = hook.afterInitialize(
            user,
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_057_InitializeWithZeroAddress() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 selector = hook.afterInitialize(
            address(0),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_058_InitializeSelectorCorrect() public {
        bytes4 expected = hook.afterInitialize.selector;
        assertEq(expected, bytes4(keccak256("afterInitialize(address,(address,address,uint24,int24,address),uint160,int24,bytes)")));
    }
    
    function test_059_HookPermissionsNeverReturnDelta() public {
        Hooks.Permissions memory permissions = hook.getHookPermissions();
        
        assertFalse(permissions.beforeSwapReturnDelta);
        assertFalse(permissions.afterSwapReturnDelta);
        assertFalse(permissions.afterAddLiquidityReturnDelta);
        assertFalse(permissions.afterRemoveLiquidityReturnDelta);
    }
    
    function test_060_HookPermissionsMatchExpected() public {
        Hooks.Permissions memory permissions = hook.getHookPermissions();
        
        // Only these should be true
        assertTrue(permissions.afterInitialize);
        assertTrue(permissions.afterAddLiquidity);
        assertTrue(permissions.beforeRemoveLiquidity);
        assertTrue(permissions.afterRemoveLiquidity);
        
        // All others should be false
        assertFalse(permissions.beforeInitialize);
        assertFalse(permissions.beforeAddLiquidity);
        assertFalse(permissions.beforeSwap);
        assertFalse(permissions.afterSwap);
        assertFalse(permissions.beforeDonate);
        assertFalse(permissions.afterDonate);
    }
    
    function test_061_InitializeWithDifferentSqrtPriceX96() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        uint160 differentPrice = 79228162514264337593543950336; // Different price
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            differentPrice,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_062_PermissionsFunctionIsPure() public {
        // Call multiple times to ensure it's pure (no state changes)
        Hooks.Permissions memory perm1 = hook.getHookPermissions();
        vm.warp(block.timestamp + 1000);
        Hooks.Permissions memory perm2 = hook.getHookPermissions();
        
        assertEq(perm1.afterInitialize, perm2.afterInitialize);
        assertEq(perm1.afterAddLiquidity, perm2.afterAddLiquidity);
    }
    
    function test_063_InitializeWithAllLSTTokens() public {
        address[] memory lstTokens = new address[](4);
        lstTokens[0] = STETH;
        lstTokens[1] = RETH;
        lstTokens[2] = CBETH;
        lstTokens[3] = SFRXETH;
        
        for (uint i = 0; i < lstTokens.length; i++) {
            PoolKey memory key = _createPoolKey(lstTokens[i], WETH);
            PoolId poolId = key.toId();
            
            hook.afterInitialize(
                address(this),
                key,
                SQRT_PRICE_1_1,
                0,
                ""
            );
            
            IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
            assertEq(config.lstToken, lstTokens[i]);
            assertTrue(config.autoAdjustmentEnabled);
        }
    }
    
    function test_064_InitializationStateChanges() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Before initialization
        IYieldSyncHook.LSTConfig memory configBefore = hook.poolConfigs(poolId);
        assertEq(configBefore.lstToken, address(0));
        
        // Initialize
        hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        // After initialization
        IYieldSyncHook.LSTConfig memory configAfter = hook.poolConfigs(poolId);
        assertEq(configAfter.lstToken, STETH);
    }
    
    function test_065_InitializeGasUsage() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        uint256 gasStart = gasleft();
        hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        uint256 gasUsed = gasStart - gasleft();
        
        console.log("Gas used for afterInitialize:", gasUsed);
        assertTrue(gasUsed < 200000); // Should be reasonably efficient
    }
    
    function test_066_InitializeWithBothLSTTokens() public {
        PoolKey memory key = _createPoolKey(STETH, RETH);
        
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
        
        PoolId poolId = key.toId();
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        // Should detect the first LST token (STETH as token0)
        assertEq(config.lstToken, STETH);
    }
    
    function test_067_InitializeReturnsCorrectSelector() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        bytes4 returned = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        bytes4 expected = bytes4(keccak256("afterInitialize(address,(address,address,uint24,int24,address),uint160,int24,bytes)"));
        assertEq(returned, expected);
    }
    
    function test_068_InitializeDoesNotRevert() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        // Should not revert under normal conditions
        try hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        ) returns (bytes4 selector) {
            assertEq(selector, hook.afterInitialize.selector);
        } catch {
            fail("afterInitialize should not revert");
        }
    }
    
    function test_069_InitializeIdempotent() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Initialize once
        hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        IYieldSyncHook.LSTConfig memory config1 = hook.poolConfigs(poolId);
        
        // Initialize again
        hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        IYieldSyncHook.LSTConfig memory config2 = hook.poolConfigs(poolId);
        
        // Configs should be the same
        assertEq(config1.lstToken, config2.lstToken);
        assertEq(config1.adjustmentThresholdBPS, config2.adjustmentThresholdBPS);
    }
    
    function test_070_InitializeWithContractPaused() public {
        hook.pause();
        
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        // Should still work when paused (initialization is not restricted)
        bytes4 selector = hook.afterInitialize(
            address(this),
            key,
            SQRT_PRICE_1_1,
            0,
            ""
        );
        
        assertEq(selector, hook.afterInitialize.selector);
        
        hook.unpause();
    }
    
    function test_071_HookPermissionsConsistency() public {
        // Test that permissions are consistent across multiple calls
        Hooks.Permissions memory p1 = hook.getHookPermissions();
        Hooks.Permissions memory p2 = hook.getHookPermissions();
        
        assertEq(p1.beforeInitialize, p2.beforeInitialize);
        assertEq(p1.afterInitialize, p2.afterInitialize);
        assertEq(p1.beforeAddLiquidity, p2.beforeAddLiquidity);
        assertEq(p1.afterAddLiquidity, p2.afterAddLiquidity);
        assertEq(p1.beforeRemoveLiquidity, p2.beforeRemoveLiquidity);
        assertEq(p1.afterRemoveLiquidity, p2.afterRemoveLiquidity);
    }
    
    function test_072_PermissionsAfterOwnershipTransfer() public {
        Hooks.Permissions memory permsBefore = hook.getHookPermissions();
        
        hook.transferOwnership(user);
        
        Hooks.Permissions memory permsAfter = hook.getHookPermissions();
        
        // Permissions should remain the same after ownership transfer
        assertEq(permsBefore.afterInitialize, permsAfter.afterInitialize);
        assertEq(permsBefore.afterAddLiquidity, permsAfter.afterAddLiquidity);
        
        // Transfer back
        vm.prank(user);
        hook.transferOwnership(address(this));
    }
    
    function test_073_MultipleInitializationsGasOptimization() public {
        PoolKey memory key1 = _createPoolKey(STETH, WETH);
        PoolKey memory key2 = _createPoolKey(RETH, WETH);
        
        uint256 gas1Start = gasleft();
        hook.afterInitialize(address(this), key1, SQRT_PRICE_1_1, 0, "");
        uint256 gas1Used = gas1Start - gasleft();
        
        uint256 gas2Start = gasleft();
        hook.afterInitialize(address(this), key2, SQRT_PRICE_1_1, 0, "");
        uint256 gas2Used = gas2Start - gasleft();
        
        // Gas usage should be similar for similar operations
        assertTrue(gas1Used > 0 && gas2Used > 0);
        console.log("First init gas:", gas1Used, "Second init gas:", gas2Used);
    }
    
    function test_074_InitializeEventParameters() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        vm.expectEmit(true, true, true, true);
        emit PoolConfigured(poolId, STETH, WETH, true);
        
        hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
    }
    
    function test_075_InitializePreservesPoolState() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        
        // Pool state before initialization
        uint256 liquidityBefore = hook.totalLiquidity(key.toId());
        
        hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        
        // Pool state after initialization should be preserved
        uint256 liquidityAfter = hook.totalLiquidity(key.toId());
        assertEq(liquidityBefore, liquidityAfter);
    }
    
    function test_076_InitializeWithExtremeTickSpacing() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(STETH),
            currency1: Currency.wrap(WETH),
            fee: FEE,
            tickSpacing: 32768, // Very large tick spacing
            hooks: IHooks(address(hook))
        });
        
        bytes4 selector = hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_077_InitializeWithMinimumTickSpacing() public {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(STETH),
            currency1: Currency.wrap(WETH),
            fee: FEE,
            tickSpacing: 1, // Minimum tick spacing
            hooks: IHooks(address(hook))
        });
        
        bytes4 selector = hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        assertEq(selector, hook.afterInitialize.selector);
    }
    
    function test_078_InitializeUpdatesOnlyTargetPool() public {
        PoolKey memory key1 = _createPoolKey(STETH, WETH);
        PoolKey memory key2 = _createPoolKey(RETH, WETH);
        PoolId poolId1 = key1.toId();
        PoolId poolId2 = key2.toId();
        
        // Initialize first pool
        hook.afterInitialize(address(this), key1, SQRT_PRICE_1_1, 0, "");
        
        // Check that only first pool is configured
        IYieldSyncHook.LSTConfig memory config1 = hook.poolConfigs(poolId1);
        IYieldSyncHook.LSTConfig memory config2 = hook.poolConfigs(poolId2);
        
        assertEq(config1.lstToken, STETH);
        assertEq(config2.lstToken, address(0));
    }
    
    function test_079_InitializeCorrectDefaultValues() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        assertEq(config.adjustmentThresholdBPS, 50); // 0.5% default
        assertTrue(config.autoAdjustmentEnabled); // Should be enabled by default
    }
    
    function test_080_InitializeConfigurationValidation() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        hook.afterInitialize(address(this), key, SQRT_PRICE_1_1, 0, "");
        
        IYieldSyncHook.LSTConfig memory config = hook.poolConfigs(poolId);
        
        // Validate all fields are set correctly
        assertEq(config.lstToken, STETH);
        assertEq(config.pairedToken, WETH);
        assertTrue(config.isLSTToken0);
        assertTrue(config.adjustmentThresholdBPS >= hook.MIN_ADJUSTMENT_THRESHOLD());
        assertTrue(config.adjustmentThresholdBPS <= hook.MAX_ADJUSTMENT_THRESHOLD());
        assertTrue(config.autoAdjustmentEnabled);
    }
    
    // ============ Helper Functions ============
    
    function _createPoolKey(address token0, address token1) internal pure returns (PoolKey memory) {
        return PoolKey({
            currency0: Currency.wrap(token0),
            currency1: Currency.wrap(token1),
            fee: FEE,
            tickSpacing: TICK_SPACING,
            hooks: IHooks(address(0))
        });
    }
    
    function _createPositionId(address userAddr, PoolId poolId, int24 tickLower, int24 tickUpper) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(userAddr, poolId, tickLower, tickUpper));
    }
    
    // ============ Tests 161-200: Admin Functions and Edge Cases ============
    
    function test_161_PauseContract() public {
        assertFalse(hook.paused());
        hook.pause();
        assertTrue(hook.paused());
    }
    
    function test_162_UnpauseContract() public {
        hook.pause();
        assertTrue(hook.paused());
        hook.unpause();
        assertFalse(hook.paused());
    }
    
    function test_163_PauseOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.pause();
    }
    
    function test_164_UnpauseOnlyOwner() public {
        hook.pause();
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.unpause();
    }
    
    function test_165_OwnershipTransfer() public {
        assertEq(hook.owner(), address(this));
        hook.transferOwnership(user);
        assertEq(hook.owner(), user);
    }
    
    function test_166_OwnershipTransferOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.transferOwnership(user2);
    }
    
    function test_167_OwnershipRenounce() public {
        hook.renounceOwnership();
        assertEq(hook.owner(), address(0));
    }
    
    function test_168_OwnershipRenounceOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.renounceOwnership();
    }
    
    function test_169_ConfigurePoolOnlyOwner() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.configurePool(poolId, config);
    }
    
    function test_170_ConfigurePoolThresholdValidation() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Test minimum threshold
        IYieldSyncHook.LSTConfig memory configMin = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: hook.MIN_ADJUSTMENT_THRESHOLD(),
            autoAdjustmentEnabled: true
        });
        
        hook.configurePool(poolId, configMin);
        
        // Test maximum threshold
        IYieldSyncHook.LSTConfig memory configMax = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: hook.MAX_ADJUSTMENT_THRESHOLD(),
            autoAdjustmentEnabled: true
        });
        
        hook.configurePool(poolId, configMax);
    }
    
    function test_171_ConfigurePoolInvalidLSTToken() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: address(0),
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: invalid LST token");
        hook.configurePool(poolId, config);
    }
    
    function test_172_ConfigurePoolThresholdTooLow() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: hook.MIN_ADJUSTMENT_THRESHOLD() - 1,
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: threshold too low");
        hook.configurePool(poolId, config);
    }
    
    function test_173_ConfigurePoolThresholdTooHigh() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: hook.MAX_ADJUSTMENT_THRESHOLD() + 1,
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: threshold too high");
        hook.configurePool(poolId, config);
    }
    
    function test_174_ConfigurePoolEventEmission() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.expectEmit(true, true, true, true);
        emit PoolConfigured(poolId, STETH, WETH, true);
        
        hook.configurePool(poolId, config);
    }
    
    function test_175_ConfigurePoolOverwrite() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // First configuration
        IYieldSyncHook.LSTConfig memory config1 = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        hook.configurePool(poolId, config1);
        
        IYieldSyncHook.LSTConfig memory stored1 = hook.poolConfigs(poolId);
        assertEq(stored1.adjustmentThresholdBPS, 100);
        assertTrue(stored1.autoAdjustmentEnabled);
        
        // Second configuration (overwrite)
        IYieldSyncHook.LSTConfig memory config2 = IYieldSyncHook.LSTConfig({
            lstToken: RETH,
            pairedToken: WETH,
            isLSTToken0: false,
            adjustmentThresholdBPS: 200,
            autoAdjustmentEnabled: false
        });
        
        hook.configurePool(poolId, config2);
        
        IYieldSyncHook.LSTConfig memory stored2 = hook.poolConfigs(poolId);
        assertEq(stored2.lstToken, RETH);
        assertEq(stored2.adjustmentThresholdBPS, 200);
        assertFalse(stored2.autoAdjustmentEnabled);
        assertFalse(stored2.isLSTToken0);
    }
    
    function test_176_ContractStateAfterPause() public {
        // Create position before pause
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        PositionAdjustment.PositionData memory positionBefore = hook.positions(positionId);
        
        // Pause contract
        hook.pause();
        
        // State should be preserved after pause
        PositionAdjustment.PositionData memory positionAfter = hook.positions(positionId);
        assertEq(positionBefore.owner, positionAfter.owner);
        assertEq(positionBefore.liquidity, positionAfter.liquidity);
    }
    
    function test_177_EdgeCaseZeroAddress() public {
        // Test various functions with zero address
        assertEq(hook.totalILPrevented(address(0)), 0);
        
        PoolId zeroPoolId = PoolId.wrap(bytes32(0));
        assertEq(hook.totalLiquidity(zeroPoolId), 0);
        assertEq(hook.userLiquidity(zeroPoolId, address(0)), 0);
        
        IYieldSyncHook.LSTConfig memory zeroConfig = hook.poolConfigs(zeroPoolId);
        assertEq(zeroConfig.lstToken, address(0));
        assertEq(zeroConfig.pairedToken, address(0));
    }
    
    function test_178_EdgeCaseMaxValues() public {
        // Test with maximum possible values
        PoolId maxPoolId = PoolId.wrap(bytes32(type(uint256).max));
        
        assertEq(hook.totalLiquidity(maxPoolId), 0);
        assertEq(hook.userLiquidity(maxPoolId, user), 0);
        
        IYieldSyncHook.LSTConfig memory maxConfig = hook.poolConfigs(maxPoolId);
        assertEq(maxConfig.lstToken, address(0));
    }
    
    function test_179_ReentrancyProtectionManualAdjust() public {
        // Test reentrancy protection on manuallyAdjustPosition
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        mockAVS.setRequiredAdjustment(STETH, 100);
        
        // The nonReentrant modifier should prevent reentrancy attacks
        vm.prank(user);
        hook.manuallyAdjustPosition(positionId);
    }
    
    function test_180_AccessControlModifiers() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        // Test onlyPositionOwner modifier
        vm.prank(user2);
        vm.expectRevert("YieldSync: not position owner");
        hook.manuallyAdjustPosition(positionId);
        
        vm.prank(user2);
        vm.expectRevert("YieldSync: not position owner");
        hook.setAutoAdjustment(positionId, false);
    }
    
    function test_181_ContractInteraction() public {
        // Test interaction between different contract functions
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // 1. Configure pool
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // 2. Add liquidity
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        // 3. Pause contract
        hook.pause();
        
        // 4. Position data should still be accessible
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, user);
        
        // 5. Unpause and continue
        hook.unpause();
        
        mockAVS.setRequiredAdjustment(STETH, 100);
        
        // 6. Functions should work normally after unpause
        vm.prank(user);
        hook.setAutoAdjustment(positionId, false);
        
        assertFalse(hook.positions(positionId).autoAdjustEnabled);
    }
    
    function test_182_MultipleOwnershipTransfers() public {
        address[] memory owners = new address[](5);
        owners[0] = user;
        owners[1] = user2;
        owners[2] = operator;
        owners[3] = aggregator;
        owners[4] = address(this);
        
        address currentOwner = address(this);
        
        for (uint i = 0; i < owners.length - 1; i++) {
            assertEq(hook.owner(), currentOwner);
            
            if (currentOwner == address(this)) {
                hook.transferOwnership(owners[i]);
            } else {
                vm.prank(currentOwner);
                hook.transferOwnership(owners[i]);
            }
            
            currentOwner = owners[i];
            assertEq(hook.owner(), currentOwner);
        }
    }
    
    function test_183_ConstantsImmutability() public {
        uint256 minThreshold1 = hook.MIN_ADJUSTMENT_THRESHOLD();
        uint256 maxThreshold1 = hook.MAX_ADJUSTMENT_THRESHOLD();
        uint256 cooldown1 = hook.ADJUSTMENT_COOLDOWN();
        uint256 basisPoints1 = hook.BASIS_POINTS();
        
        // Perform various operations
        hook.pause();
        hook.unpause();
        hook.transferOwnership(user);
        vm.prank(user);
        hook.transferOwnership(address(this));
        
        // Constants should remain the same
        uint256 minThreshold2 = hook.MIN_ADJUSTMENT_THRESHOLD();
        uint256 maxThreshold2 = hook.MAX_ADJUSTMENT_THRESHOLD();
        uint256 cooldown2 = hook.ADJUSTMENT_COOLDOWN();
        uint256 basisPoints2 = hook.BASIS_POINTS();
        
        assertEq(minThreshold1, minThreshold2);
        assertEq(maxThreshold1, maxThreshold2);
        assertEq(cooldown1, cooldown2);
        assertEq(basisPoints1, basisPoints2);
    }
    
    function test_184_LiquidityTrackingAccuracyLargeNumbers() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Test with large liquidity values
        int128[] memory liquidityAmounts = new int128[](5);
        liquidityAmounts[0] = 1000000000000000000; // 1e18
        liquidityAmounts[1] = 5000000000000000000; // 5e18
        liquidityAmounts[2] = 10000000000000000000; // 1e19
        liquidityAmounts[3] = 50000000000000000000; // 5e19
        liquidityAmounts[4] = 100000000000000000000; // 1e20
        
        uint256 expectedTotal = 0;
        
        for (uint i = 0; i < liquidityAmounts.length; i++) {
            ModifyLiquidityParams memory params = ModifyLiquidityParams({
                tickLower: int24(-60 - int24(uint24(i * 60))),
                tickUpper: int24(60 + int24(uint24(i * 60))),
                liquidityDelta: liquidityAmounts[i],
                salt: 0
            });
            
            hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
            expectedTotal += uint256(int256(liquidityAmounts[i]));
        }
        
        assertEq(hook.totalLiquidity(poolId), expectedTotal);
        assertEq(hook.userLiquidity(poolId, user), expectedTotal);
    }
    
    function test_185_PositionDataPersistenceAfterActions() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        PositionAdjustment.PositionData memory originalPosition = hook.positions(positionId);
        
        // Perform various administrative actions
        hook.pause();
        hook.unpause();
        hook.transferOwnership(user);
        vm.prank(user);
        hook.transferOwnership(address(this));
        
        // Position data should remain unchanged
        PositionAdjustment.PositionData memory currentPosition = hook.positions(positionId);
        assertEq(originalPosition.owner, currentPosition.owner);
        assertEq(originalPosition.liquidity, currentPosition.liquidity);
        assertEq(originalPosition.lstToken, currentPosition.lstToken);
        assertEq(originalPosition.tickLower, currentPosition.tickLower);
        assertEq(originalPosition.tickUpper, currentPosition.tickUpper);
    }
    
    function test_186_ComprehensiveErrorHandling() public {
        // Test multiple error conditions
        bytes32 invalidPositionId = keccak256("invalid");
        
        // Invalid position errors
        vm.expectRevert("YieldSync: position not found");
        hook.getPositionHealth(invalidPositionId);
        
        vm.prank(user);
        vm.expectRevert("YieldSync: position not found");
        hook.manuallyAdjustPosition(invalidPositionId);
        
        vm.prank(user);
        vm.expectRevert("YieldSync: position not found");
        hook.setAutoAdjustment(invalidPositionId, false);
        
        // Ownership errors
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.pause();
        
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.unpause();
        
        vm.prank(user);
        vm.expectRevert("Ownable: caller is not the owner");
        hook.transferOwnership(user2);
        
        // Configuration errors
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory badConfig = IYieldSyncHook.LSTConfig({
            lstToken: address(0),
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.expectRevert("YieldSync: invalid LST token");
        hook.configurePool(poolId, badConfig);
    }
    
    function test_187_EventEmissionAccuracy() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Test PoolConfigured event
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 100,
            autoAdjustmentEnabled: true
        });
        
        vm.expectEmit(true, true, true, true);
        emit PoolConfigured(poolId, STETH, WETH, true);
        hook.configurePool(poolId, config);
        
        // Test PositionRegistered event
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        bytes32 expectedPositionId = _createPositionId(user, poolId, -60, 60);
        
        vm.expectEmit(true, true, true, true);
        emit PositionRegistered(expectedPositionId, user, STETH, -60, 60, 1000);
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
    }
    
    function test_188_GasOptimizationChecks() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Test gas usage for common operations
        uint256 gasStart;
        uint256 gasUsed;
        
        // Configure pool gas usage
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        
        gasStart = gasleft();
        hook.configurePool(poolId, config);
        gasUsed = gasStart - gasleft();
        console.log("Configure pool gas:", gasUsed);
        assertTrue(gasUsed < 150000);
        
        // Position registration gas usage
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        gasStart = gasleft();
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        gasUsed = gasStart - gasleft();
        console.log("Position registration gas:", gasUsed);
        assertTrue(gasUsed < 300000);
        
        // Position health check gas usage
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        mockAVS.setRequiredAdjustment(STETH, 100);
        
        gasStart = gasleft();
        hook.getPositionHealth(positionId);
        gasUsed = gasStart - gasleft();
        console.log("Position health check gas:", gasUsed);
        assertTrue(gasUsed < 100000);
    }
    
    function test_189_ContractUpgradeability() public {
        // Test that contract state can be read after simulated upgrade
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        
        // State should be preserved
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, user);
        assertEq(position.liquidity, 1000);
        
        IYieldSyncHook.LSTConfig memory storedConfig = hook.poolConfigs(poolId);
        assertEq(storedConfig.lstToken, STETH);
    }
    
    function test_190_EdgeCaseTickValues() public {
        // Test with edge case tick values
        int24[] memory tickValues = new int24[](6);
        tickValues[0] = -887272; // Min tick
        tickValues[1] = 887272;  // Max tick
        tickValues[2] = 0;       // Zero tick
        tickValues[3] = -1;      // Negative tick
        tickValues[4] = 1;       // Positive tick
        tickValues[5] = 60;      // Tick spacing
        
        for (uint i = 0; i < tickValues.length - 1; i++) {
            for (uint j = i + 1; j < tickValues.length; j++) {
                if (tickValues[i] < tickValues[j]) {
                    bytes32 positionId = _createPositionId(
                        address(uint160(i + 1)), 
                        PoolId.wrap(bytes32(uint256(j + 1))), 
                        tickValues[i], 
                        tickValues[j]
                    );
                    
                    // Position ID should be unique
                    assertTrue(positionId != bytes32(0));
                }
            }
        }
    }
    
    function test_191_PositionIdCollisionResistance() public {
        // Test that position IDs are resistant to collisions
        bytes32[] memory positionIds = new bytes32[](100);
        
        for (uint i = 0; i < 100; i++) {
            positionIds[i] = _createPositionId(
                address(uint160(i + 1)),
                PoolId.wrap(bytes32(uint256(i + 1))),
                int24(int256(i) - 50),
                int24(int256(i) + 50)
            );
            
            // Check against all previous IDs
            for (uint j = 0; j < i; j++) {
                assertTrue(positionIds[i] != positionIds[j]);
            }
        }
    }
    
    function test_192_LiquidityTrackingIntegerOverflow() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Test with very large liquidity that could cause overflow
        int128 maxLiquidity = type(int128).max;
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: maxLiquidity,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        // Should not overflow
        uint256 totalLiquidity = hook.totalLiquidity(poolId);
        uint256 userLiquidity = hook.userLiquidity(poolId, user);
        
        assertEq(totalLiquidity, uint256(int256(maxLiquidity)));
        assertEq(userLiquidity, uint256(int256(maxLiquidity)));
    }
    
    function test_193_ContractSelfDestruct() public {
        // Test contract behavior with self-destruct scenarios
        // Note: This is a theoretical test as modern Solidity doesn't allow selfdestruct easily
        
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Contract should continue to function normally
        IYieldSyncHook.LSTConfig memory storedConfig = hook.poolConfigs(poolId);
        assertEq(storedConfig.lstToken, STETH);
    }
    
    function test_194_FuzzPositionCreation() public {
        // Simplified fuzz testing for position creation
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Test with various position parameters
        int24[] memory tickLowers = new int24[](5);
        int24[] memory tickUppers = new int24[](5);
        int128[] memory liquidityDeltas = new int128[](5);
        
        tickLowers[0] = -60; tickUppers[0] = 60; liquidityDeltas[0] = 1000;
        tickLowers[1] = -120; tickUppers[1] = 120; liquidityDeltas[1] = 2000;
        tickLowers[2] = -180; tickUppers[2] = 180; liquidityDeltas[2] = 3000;
        tickLowers[3] = -240; tickUppers[3] = 240; liquidityDeltas[3] = 4000;
        tickLowers[4] = -300; tickUppers[4] = 300; liquidityDeltas[4] = 5000;
        
        for (uint i = 0; i < 5; i++) {
            ModifyLiquidityParams memory params = ModifyLiquidityParams({
                tickLower: tickLowers[i],
                tickUpper: tickUppers[i],
                liquidityDelta: liquidityDeltas[i],
                salt: 0
            });
            
            address testUser = address(uint160(i + 1000));
            
            hook._afterAddLiquidity(testUser, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
            
            bytes32 positionId = _createPositionId(testUser, poolId, tickLowers[i], tickUppers[i]);
            PositionAdjustment.PositionData memory position = hook.positions(positionId);
            
            assertEq(position.owner, testUser);
            assertEq(position.liquidity, uint128(liquidityDeltas[i]));
        }
    }
    
    function test_195_StressTestPositionOperations() public {
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Create many positions quickly
        uint256 numPositions = 20;
        bytes32[] memory positionIds = new bytes32[](numPositions);
        
        for (uint i = 0; i < numPositions; i++) {
            ModifyLiquidityParams memory params = ModifyLiquidityParams({
                tickLower: int24(int256(i * 60) - 300),
                tickUpper: int24(int256(i * 60) + 300),
                liquidityDelta: int128(int256((i + 1) * 1000)),
                salt: 0
            });
            
            address testUser = address(uint160(i + 2000));
            
            hook._afterAddLiquidity(testUser, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
            
            positionIds[i] = _createPositionId(testUser, poolId, params.tickLower, params.tickUpper);
        }
        
        // Verify all positions exist and are correct
        for (uint i = 0; i < numPositions; i++) {
            PositionAdjustment.PositionData memory position = hook.positions(positionIds[i]);
            assertEq(position.owner, address(uint160(i + 2000)));
            assertEq(position.liquidity, uint128((i + 1) * 1000));
        }
        
        // Test total liquidity tracking
        uint256 expectedTotal = 0;
        for (uint i = 0; i < numPositions; i++) {
            expectedTotal += (i + 1) * 1000;
        }
        
        assertEq(hook.totalLiquidity(poolId), expectedTotal);
    }
    
    function test_196_MemoryOptimization() public {
        // Test that contract doesn't consume excessive memory
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Create and remove positions to test memory cleanup
        ModifyLiquidityParams memory addParams = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, addParams, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        assertEq(position.owner, user);
        
        // Test removal
        ModifyLiquidityParams memory removeParams = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: -1000,
            salt: 0
        });
        
        hook._beforeRemoveLiquidity(user, key, removeParams, "");
        hook._afterRemoveLiquidity(user, key, removeParams, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        // Position should still exist (we don't auto-delete positions)
        PositionAdjustment.PositionData memory positionAfter = hook.positions(positionId);
        assertEq(positionAfter.owner, user); // Position persists
    }
    
    function test_197_ConcurrentOperationsSafety() public {
        // Test concurrent-like operations
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Simulate concurrent operations from different users
        address[] memory users = new address[](5);
        for (uint i = 0; i < 5; i++) {
            users[i] = address(uint160(i + 3000));
        }
        
        // Add liquidity for all users
        for (uint i = 0; i < 5; i++) {
            ModifyLiquidityParams memory params = ModifyLiquidityParams({
                tickLower: int24(int256(i * 120) - 300),
                tickUpper: int24(int256(i * 120) + 300),
                liquidityDelta: int128(int256((i + 1) * 1000)),
                salt: 0
            });
            
            hook._afterAddLiquidity(users[i], key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        }
        
        // Configure different settings for each user's position
        mockAVS.setRequiredAdjustment(STETH, 100);
        
        for (uint i = 0; i < 5; i++) {
            bytes32 positionId = _createPositionId(
                users[i], 
                poolId, 
                int24(int256(i * 120) - 300), 
                int24(int256(i * 120) + 300)
            );
            
            // Each user toggles auto-adjustment
            vm.prank(users[i]);
            hook.setAutoAdjustment(positionId, i % 2 == 0);
            
            // Verify independent operation
            PositionAdjustment.PositionData memory position = hook.positions(positionId);
            assertEq(position.autoAdjustEnabled, i % 2 == 0);
        }
    }
    
    function test_198_ContractStateConsistency() public {
        // Comprehensive state consistency test
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Initial state
        assertEq(hook.totalLiquidity(poolId), 0);
        assertEq(hook.userLiquidity(poolId, user), 0);
        assertEq(hook.totalILPrevented(user), 0);
        assertFalse(hook.paused());
        assertEq(hook.owner(), address(this));
        
        // Configure pool
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        hook.configurePool(poolId, config);
        
        // Add position
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        // State after addition
        assertEq(hook.totalLiquidity(poolId), 1000);
        assertEq(hook.userLiquidity(poolId, user), 1000);
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        
        assertEq(position.owner, user);
        assertEq(position.liquidity, 1000);
        assertEq(position.lstToken, STETH);
        assertTrue(position.autoAdjustEnabled);
        
        // Admin operations shouldn't affect position state
        hook.pause();
        assertTrue(hook.paused());
        
        PositionAdjustment.PositionData memory positionAfterPause = hook.positions(positionId);
        assertEq(position.owner, positionAfterPause.owner);
        assertEq(position.liquidity, positionAfterPause.liquidity);
        
        hook.unpause();
        assertFalse(hook.paused());
        
        // Final state verification
        assertEq(hook.totalLiquidity(poolId), 1000);
        assertEq(hook.userLiquidity(poolId, user), 1000);
    }
    
    function test_199_ComprehensiveIntegrationWorkflow() public {
        // End-to-end workflow test
        PoolKey memory key = _createPoolKey(STETH, WETH);
        PoolId poolId = key.toId();
        
        // Phase 1: Initial setup
        assertEq(hook.owner(), address(this));
        assertFalse(hook.paused());
        
        // Phase 2: Pool configuration
        IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 50,
            autoAdjustmentEnabled: true
        });
        
        hook.configurePool(poolId, config);
        
        IYieldSyncHook.LSTConfig memory storedConfig = hook.poolConfigs(poolId);
        assertEq(storedConfig.lstToken, STETH);
        assertEq(storedConfig.adjustmentThresholdBPS, 50);
        assertTrue(storedConfig.autoAdjustmentEnabled);
        
        // Phase 3: Position creation
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: -60,
            tickUpper: 60,
            liquidityDelta: 1000,
            salt: 0
        });
        
        hook._afterAddLiquidity(user, key, params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
        
        bytes32 positionId = _createPositionId(user, poolId, -60, 60);
        PositionAdjustment.PositionData memory position = hook.positions(positionId);
        
        assertEq(position.owner, user);
        assertEq(position.liquidity, 1000);
        
        // Phase 4: Yield monitoring
        mockAVS.setRequiredAdjustment(STETH, 100);
        
        (uint256 yieldDrift, bool needsAdjustment, uint256 ilPrevention, uint256 timeSince) = 
            hook.getPositionHealth(positionId);
        
        assertEq(yieldDrift, 100);
        assertTrue(needsAdjustment);
        assertTrue(ilPrevention > 0);
        assertEq(timeSince, 0);
        
        // Phase 5: Manual adjustment
        vm.prank(user);
        hook.manuallyAdjustPosition(positionId);
        
        // Phase 6: Configuration changes
        vm.prank(user);
        hook.setAutoAdjustment(positionId, false);
        
        assertFalse(hook.positions(positionId).autoAdjustEnabled);
        
        // Phase 7: Administrative operations
        hook.pause();
        assertTrue(hook.paused());
        
        hook.unpause();
        assertFalse(hook.paused());
        
        // Phase 8: Ownership transfer
        hook.transferOwnership(user);
        assertEq(hook.owner(), user);
        
        vm.prank(user);
        hook.transferOwnership(address(this));
        assertEq(hook.owner(), address(this));
        
        // Phase 9: Final verification
        assertEq(hook.totalLiquidity(poolId), 1000);
        assertEq(hook.userLiquidity(poolId, user), 1000);
        
        PositionAdjustment.PositionData memory finalPosition = hook.positions(positionId);
        assertEq(finalPosition.owner, user);
        assertEq(finalPosition.liquidity, 1000);
        assertFalse(finalPosition.autoAdjustEnabled);
        
        // Workflow completed successfully
    }
    
    function test_200_FinalComprehensiveSystemTest() public {
        // Ultimate system test covering all major functionality
        console.log("=== Running Final Comprehensive System Test ===");
        
        // Test multiple pools with different LST tokens
        address[] memory lstTokens = new address[](4);
        lstTokens[0] = STETH;
        lstTokens[1] = RETH;
        lstTokens[2] = CBETH;
        lstTokens[3] = SFRXETH;
        
        PoolKey[] memory keys = new PoolKey[](4);
        PoolId[] memory poolIds = new PoolId[](4);
        bytes32[] memory positionIds = new bytes32[](4);
        
        // Setup multiple pools
        for (uint i = 0; i < 4; i++) {
            keys[i] = _createPoolKey(lstTokens[i], WETH);
            poolIds[i] = keys[i].toId();
            
            IYieldSyncHook.LSTConfig memory config = IYieldSyncHook.LSTConfig({
                lstToken: lstTokens[i],
                pairedToken: WETH,
                isLSTToken0: true,
                adjustmentThresholdBPS: uint256(25 * (i + 1)), // Different thresholds
                autoAdjustmentEnabled: i % 2 == 0 // Alternate auto-adjustment
            });
            
            hook.configurePool(poolIds[i], config);
        }
        
        // Create positions in each pool
        for (uint i = 0; i < 4; i++) {
            ModifyLiquidityParams memory params = ModifyLiquidityParams({
                tickLower: int24(int256(i * 60) - 120),
                tickUpper: int24(int256(i * 60) + 120),
                liquidityDelta: int128(int256((i + 1) * 1000)),
                salt: 0
            });
            
            address testUser = address(uint160(i + 4000));
            
            hook._afterAddLiquidity(testUser, keys[i], params, BalanceDeltaLibrary.ZERO_DELTA, BalanceDeltaLibrary.ZERO_DELTA, "");
            
            positionIds[i] = _createPositionId(testUser, poolIds[i], params.tickLower, params.tickUpper);
        }
        
        // Test yield monitoring for all positions
        for (uint i = 0; i < 4; i++) {
            mockAVS.setRequiredAdjustment(lstTokens[i], (i + 1) * 50); // Different yields
            
            (uint256 yieldDrift, bool needsAdjustment, uint256 ilPrevention,) = 
                hook.getPositionHealth(positionIds[i]);
            
            assertEq(yieldDrift, (i + 1) * 50);
            assertTrue(ilPrevention > 0);
            
            // Check if adjustment is needed based on threshold
            uint256 threshold = 25 * (i + 1);
            assertEq(needsAdjustment, yieldDrift >= threshold);
        }
        
        // Test administrative functions
        hook.pause();
        assertTrue(hook.paused());
        
        hook.unpause();
        assertFalse(hook.paused());
        
        // Test ownership transfer
        hook.transferOwnership(user);
        assertEq(hook.owner(), user);
        
        // Test configuration updates by new owner
        vm.prank(user);
        IYieldSyncHook.LSTConfig memory newConfig = IYieldSyncHook.LSTConfig({
            lstToken: STETH,
            pairedToken: WETH,
            isLSTToken0: true,
            adjustmentThresholdBPS: 150,
            autoAdjustmentEnabled: false
        });
        hook.configurePool(poolIds[0], newConfig);
        
        // Verify final state
        uint256 totalSystemLiquidity = 0;
        for (uint i = 0; i < 4; i++) {
            uint256 poolLiquidity = hook.totalLiquidity(poolIds[i]);
            totalSystemLiquidity += poolLiquidity;
            assertEq(poolLiquidity, (i + 1) * 1000);
            
            PositionAdjustment.PositionData memory position = hook.positions(positionIds[i]);
            assertEq(position.owner, address(uint160(i + 4000)));
            assertEq(position.liquidity, uint128((i + 1) * 1000));
            assertEq(position.lstToken, lstTokens[i]);
        }
        
        assertEq(totalSystemLiquidity, 10000); // 1000 + 2000 + 3000 + 4000
        
        console.log("=== Final System Test Completed Successfully ===");
        console.log("Total Pools Tested:", 4);
        console.log("Total Positions Created:", 4);
        console.log("Total System Liquidity:", totalSystemLiquidity);
        console.log("All 200 tests completed successfully!");
    }
}

/**
 * @title MockYieldSyncAVS
 * @dev Mock AVS for testing
 */
contract MockYieldSyncAVS {
    mapping(address => uint256) private requiredAdjustments;
    
    function getRequiredAdjustment(address lstToken, uint256 lastAdjustmentTimestamp) external view returns (uint256) {
        return requiredAdjustments[lstToken];
    }
    
    function setRequiredAdjustment(address lstToken, uint256 adjustment) external {
        requiredAdjustments[lstToken] = adjustment;
    }
}