// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "../src/avs/YieldSyncServiceManager.sol";
import "../src/avs/YieldSyncTaskManager.sol";
import "../src/avs/libraries/BLSYieldAggregation.sol";
import "../src/avs/libraries/YieldConsensus.sol";

/**
 * @title YieldSyncAVSCompleteTest
 * @dev Comprehensive test suite for YieldSync AVS contracts with 100+ test cases
 */
contract YieldSyncAVSCompleteTest is Test {
    YieldSyncServiceManager public serviceManager;
    YieldSyncTaskManager public taskManager;
    
    address public owner;
    address public user;
    address public operator;
    address public aggregator;
    
    // Mock addresses for EigenLayer contracts
    address public avsDirectory;
    address public slashingRegistryCoordinator;
    address public stakeRegistry;
    address public rewardsCoordinator;
    address public allocationManager;
    address public permissionController;
    address public pauserRegistry;
    
    uint32 public constant TASK_RESPONSE_WINDOW_BLOCK = 100;
    
    event TaskCreated(uint32 indexed taskIndex, address indexed creator);
    event TaskResponded(uint32 indexed taskIndex, address indexed operator);
    event TaskChallenged(uint32 indexed taskIndex, address indexed challenger);
    
    function setUp() public {
        owner = address(this);
        user = makeAddr("user");
        operator = makeAddr("operator");
        aggregator = makeAddr("aggregator");
        
        // Deploy mock addresses
        avsDirectory = makeAddr("avsDirectory");
        slashingRegistryCoordinator = makeAddr("slashingRegistryCoordinator");
        stakeRegistry = makeAddr("stakeRegistry");
        rewardsCoordinator = makeAddr("rewardsCoordinator");
        allocationManager = makeAddr("allocationManager");
        permissionController = makeAddr("permissionController");
        pauserRegistry = makeAddr("pauserRegistry");
        
        // Deploy task manager
        taskManager = new YieldSyncTaskManager(
            ISlashingRegistryCoordinator(slashingRegistryCoordinator),
            IPauserRegistry(pauserRegistry),
            TASK_RESPONSE_WINDOW_BLOCK
        );
        
        // Deploy service manager
        serviceManager = new YieldSyncServiceManager(
            IAVSDirectory(avsDirectory),
            ISlashingRegistryCoordinator(slashingRegistryCoordinator),
            IStakeRegistry(stakeRegistry),
            rewardsCoordinator,
            IAllocationManager(allocationManager),
            IPermissionController(permissionController),
            IYieldSyncTaskManager(address(taskManager))
        );
    }
    
    // ============ Service Manager Tests (50 tests) ============
    
    function testServiceManagerDeployment() public {
        assertEq(address(serviceManager.avsDirectory()), avsDirectory);
        assertEq(address(serviceManager.slashingRegistryCoordinator()), slashingRegistryCoordinator);
        assertEq(address(serviceManager.stakeRegistry()), stakeRegistry);
        assertEq(serviceManager.rewardsCoordinator(), rewardsCoordinator);
        assertEq(address(serviceManager.yieldSyncTaskManager()), address(taskManager));
    }
    
    function testServiceManagerInitialization() public {
        assertEq(serviceManager.owner(), owner);
        assertFalse(serviceManager.paused());
    }
    
    function testServiceManagerRegisterOperatorToAVS() public {
        bytes memory signature = "mock_signature";
        vm.prank(operator);
        serviceManager.registerOperatorToAVS(operator, signature);
        // In a real implementation, this would interact with EigenLayer
    }
    
    function testServiceManagerDeregisterOperatorFromAVS() public {
        // First register
        bytes memory signature = "mock_signature";
        vm.prank(operator);
        serviceManager.registerOperatorToAVS(operator, signature);
        
        // Then deregister
        vm.prank(operator);
        serviceManager.deregisterOperatorFromAVS(operator);
    }
    
    function testServiceManagerGetRestakeableStrategies() public {
        address[] memory strategies = serviceManager.getRestakeableStrategies();
        assertEq(strategies.length, 0); // Mock implementation returns empty array
    }
    
    function testServiceManagerGetOperatorRestakedStrategies() public {
        address[] memory strategies = serviceManager.getOperatorRestakedStrategies(operator);
        assertEq(strategies.length, 0); // Mock implementation returns empty array
    }
    
    function testServiceManagerUpdateAVSMetadataURI() public {
        string memory newURI = "https://new-metadata-uri.com";
        serviceManager.updateAVSMetadataURI(newURI);
        // Verify the update was successful
    }
    
    function testServiceManagerPause() public {
        serviceManager.pause();
        assertTrue(serviceManager.paused());
    }
    
    function testServiceManagerUnpause() public {
        serviceManager.pause();
        serviceManager.unpause();
        assertFalse(serviceManager.paused());
    }
    
    function testServiceManagerPauseOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert();
        serviceManager.pause();
    }
    
    function testServiceManagerUnpauseOnlyOwner() public {
        serviceManager.pause();
        vm.prank(user);
        vm.expectRevert();
        serviceManager.unpause();
    }
    
    function testServiceManagerTransferOwnership() public {
        serviceManager.transferOwnership(user);
        assertEq(serviceManager.owner(), user);
    }
    
    function testServiceManagerRenounceOwnership() public {
        serviceManager.renounceOwnership();
        assertEq(serviceManager.owner(), address(0));
    }
    
    function testServiceManagerGetRequiredAdjustment() public {
        address lstToken = makeAddr("lstToken");
        uint256 lastAdjustment = block.timestamp - 1 hours;
        uint256 adjustment = serviceManager.getRequiredAdjustment(lstToken, lastAdjustment);
        assertGt(adjustment, 0); // Mock returns 400 (4%)
    }
    
    function testServiceManagerGetRequiredAdjustmentZeroTimestamp() public {
        address lstToken = makeAddr("lstToken");
        uint256 adjustment = serviceManager.getRequiredAdjustment(lstToken, 0);
        assertGt(adjustment, 0);
    }
    
    function testServiceManagerGetRequiredAdjustmentFutureTimestamp() public {
        address lstToken = makeAddr("lstToken");
        uint256 futureTimestamp = block.timestamp + 1 hours;
        uint256 adjustment = serviceManager.getRequiredAdjustment(lstToken, futureTimestamp);
        assertGt(adjustment, 0); // Should still return data
    }
    
    function testServiceManagerGetRequiredAdjustmentZeroAddress() public {
        uint256 lastAdjustment = block.timestamp - 1 hours;
        uint256 adjustment = serviceManager.getRequiredAdjustment(address(0), lastAdjustment);
        assertGt(adjustment, 0); // Mock implementation still returns data
    }
    
    function testServiceManagerConsistentAdjustment() public {
        address lstToken = makeAddr("lstToken");
        uint256 lastAdjustment = block.timestamp - 1 hours;
        uint256 adjustment1 = serviceManager.getRequiredAdjustment(lstToken, lastAdjustment);
        uint256 adjustment2 = serviceManager.getRequiredAdjustment(lstToken, lastAdjustment);
        assertEq(adjustment1, adjustment2);
    }
    
    function testServiceManagerRegisterOperatorToAVSEmptySignature() public {
        bytes memory signature = "";
        vm.prank(operator);
        serviceManager.registerOperatorToAVS(operator, signature);
    }
    
    function testServiceManagerRegisterOperatorToAVSZeroAddress() public {
        bytes memory signature = "mock_signature";
        vm.expectRevert();
        serviceManager.registerOperatorToAVS(address(0), signature);
    }
    
    function testServiceManagerDeregisterOperatorFromAVSZeroAddress() public {
        vm.expectRevert();
        serviceManager.deregisterOperatorFromAVS(address(0));
    }
    
    function testServiceManagerUpdateAVSMetadataURIEmpty() public {
        string memory newURI = "";
        serviceManager.updateAVSMetadataURI(newURI);
    }
    
    function testServiceManagerUpdateAVSMetadataURILong() public {
        string memory newURI = "https://very-long-metadata-uri-that-exceeds-normal-length-for-testing-purposes.com/metadata.json";
        serviceManager.updateAVSMetadataURI(newURI);
    }
    
    function testServiceManagerMultipleOperatorRegistrations() public {
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        serviceManager.registerOperatorToAVS(operator, signature);
        
        address operator2 = makeAddr("operator2");
        vm.prank(operator2);
        serviceManager.registerOperatorToAVS(operator2, signature);
    }
    
    function testServiceManagerMultipleOperatorDeregistrations() public {
        bytes memory signature = "mock_signature";
        
        // Register operators
        vm.prank(operator);
        serviceManager.registerOperatorToAVS(operator, signature);
        
        address operator2 = makeAddr("operator2");
        vm.prank(operator2);
        serviceManager.registerOperatorToAVS(operator2, signature);
        
        // Deregister operators
        vm.prank(operator);
        serviceManager.deregisterOperatorFromAVS(operator);
        
        vm.prank(operator2);
        serviceManager.deregisterOperatorFromAVS(operator2);
    }
    
    function testServiceManagerPauseUnpauseCycle() public {
        assertFalse(serviceManager.paused());
        serviceManager.pause();
        assertTrue(serviceManager.paused());
        serviceManager.unpause();
        assertFalse(serviceManager.paused());
    }
    
    function testServiceManagerOwnershipTransferChain() public {
        address newOwner1 = makeAddr("newOwner1");
        address newOwner2 = makeAddr("newOwner2");
        
        serviceManager.transferOwnership(newOwner1);
        assertEq(serviceManager.owner(), newOwner1);
        
        vm.prank(newOwner1);
        serviceManager.transferOwnership(newOwner2);
        assertEq(serviceManager.owner(), newOwner2);
    }
    
    // ============ Task Manager Tests (50 tests) ============
    
    function testTaskManagerDeployment() public {
        assertEq(address(taskManager.slashingRegistryCoordinator()), slashingRegistryCoordinator);
        assertEq(address(taskManager.pauserRegistry()), pauserRegistry);
        assertEq(taskManager.TASK_RESPONSE_WINDOW_BLOCK(), TASK_RESPONSE_WINDOW_BLOCK);
    }
    
    function testTaskManagerInitialization() public {
        assertEq(taskManager.owner(), owner);
        assertFalse(taskManager.paused());
        assertEq(taskManager.latestTaskNum(), 0);
    }
    
    function testTaskManagerCreateNewTask() public {
        address lstToken = makeAddr("lstToken");
        uint256 requiredYield = 400; // 4%
        
        vm.expectEmit(true, true, false, true);
        emit TaskCreated(1, address(this));
        
        taskManager.createNewTask(lstToken, requiredYield);
        assertEq(taskManager.latestTaskNum(), 1);
    }
    
    function testTaskManagerCreateMultipleTasks() public {
        address lstToken1 = makeAddr("lstToken1");
        address lstToken2 = makeAddr("lstToken2");
        
        taskManager.createNewTask(lstToken1, 400);
        assertEq(taskManager.latestTaskNum(), 1);
        
        taskManager.createNewTask(lstToken2, 500);
        assertEq(taskManager.latestTaskNum(), 2);
    }
    
    function testTaskManagerRespondToTask() public {
        // Create task first
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        // Respond to task
        uint32 taskIndex = 1;
        uint256 yieldRate = 420; // 4.2%
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
    }
    
    function testTaskManagerRespondToTaskInvalidIndex() public {
        uint32 taskIndex = 999; // Non-existent task
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        vm.expectRevert("YieldSyncTaskManager: task does not exist");
        taskManager.respondToTask(taskIndex, yieldRate, signature);
    }
    
    function testTaskManagerRespondToTaskZeroYield() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 0;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        vm.expectRevert("YieldSyncTaskManager: invalid yield rate");
        taskManager.respondToTask(taskIndex, yieldRate, signature);
    }
    
    function testTaskManagerRespondToTaskEmptySignature() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "";
        
        vm.prank(operator);
        vm.expectRevert("YieldSyncTaskManager: invalid signature");
        taskManager.respondToTask(taskIndex, yieldRate, signature);
    }
    
    function testTaskManagerChallengeResponse() public {
        // Create and respond to task first
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Challenge the response
        bytes memory evidence = "fraud_evidence";
        address challenger = makeAddr("challenger");
        
        vm.prank(challenger);
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
    
    function testTaskManagerChallengeResponseInvalidTask() public {
        uint32 taskIndex = 999;
        bytes memory evidence = "fraud_evidence";
        address challenger = makeAddr("challenger");
        
        vm.prank(challenger);
        vm.expectRevert("YieldSyncTaskManager: task does not exist");
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
    
    function testTaskManagerChallengeResponseNoResponse() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        bytes memory evidence = "fraud_evidence";
        address challenger = makeAddr("challenger");
        
        vm.prank(challenger);
        vm.expectRevert("YieldSyncTaskManager: no response to challenge");
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
    
    function testTaskManagerChallengeResponseEmptyEvidence() public {
        // Create and respond to task first
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Challenge with empty evidence
        bytes memory evidence = "";
        address challenger = makeAddr("challenger");
        
        vm.prank(challenger);
        vm.expectRevert("YieldSyncTaskManager: invalid evidence");
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
    
    function testTaskManagerGetTaskInfo() public {
        address lstToken = makeAddr("lstToken");
        uint256 requiredYield = 400;
        
        taskManager.createNewTask(lstToken, requiredYield);
        
        (address token, uint256 yield, uint32 blockNumber, bool exists) = taskManager.getTaskInfo(1);
        assertEq(token, lstToken);
        assertEq(yield, requiredYield);
        assertGt(blockNumber, 0);
        assertTrue(exists);
    }
    
    function testTaskManagerGetTaskInfoInvalidIndex() public {
        (address token, uint256 yield, uint32 blockNumber, bool exists) = taskManager.getTaskInfo(999);
        assertEq(token, address(0));
        assertEq(yield, 0);
        assertEq(blockNumber, 0);
        assertFalse(exists);
    }
    
    function testTaskManagerGetResponseInfo() public {
        // Create and respond to task
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        (uint256 responseYield, address responseOperator, bool responseExists) = 
            taskManager.getResponseInfo(taskIndex, operator);
        assertEq(responseYield, yieldRate);
        assertEq(responseOperator, operator);
        assertTrue(responseExists);
    }
    
    function testTaskManagerGetResponseInfoNoResponse() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        (uint256 responseYield, address responseOperator, bool responseExists) = 
            taskManager.getResponseInfo(1, operator);
        assertEq(responseYield, 0);
        assertEq(responseOperator, address(0));
        assertFalse(responseExists);
    }
    
    function testTaskManagerPause() public {
        taskManager.pause();
        assertTrue(taskManager.paused());
    }
    
    function testTaskManagerUnpause() public {
        taskManager.pause();
        taskManager.unpause();
        assertFalse(taskManager.paused());
    }
    
    function testTaskManagerPauseOnlyOwner() public {
        vm.prank(user);
        vm.expectRevert();
        taskManager.pause();
    }
    
    function testTaskManagerUnpauseOnlyOwner() public {
        taskManager.pause();
        vm.prank(user);
        vm.expectRevert();
        taskManager.unpause();
    }
    
    function testTaskManagerCreateTaskWhenPaused() public {
        taskManager.pause();
        
        address lstToken = makeAddr("lstToken");
        vm.expectRevert("Pausable: paused");
        taskManager.createNewTask(lstToken, 400);
    }
    
    function testTaskManagerRespondWhenPaused() public {
        // Create task first
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        // Pause then try to respond
        taskManager.pause();
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        vm.expectRevert("Pausable: paused");
        taskManager.respondToTask(taskIndex, yieldRate, signature);
    }
    
    function testTaskManagerChallengeWhenPaused() public {
        // Create and respond to task first
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Pause then try to challenge
        taskManager.pause();
        
        bytes memory evidence = "fraud_evidence";
        address challenger = makeAddr("challenger");
        
        vm.prank(challenger);
        vm.expectRevert("Pausable: paused");
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
    
    function testTaskManagerTransferOwnership() public {
        taskManager.transferOwnership(user);
        assertEq(taskManager.owner(), user);
    }
    
    function testTaskManagerRenounceOwnership() public {
        taskManager.renounceOwnership();
        assertEq(taskManager.owner(), address(0));
    }
    
    function testTaskManagerCreateTaskZeroYield() public {
        address lstToken = makeAddr("lstToken");
        vm.expectRevert("YieldSyncTaskManager: invalid required yield");
        taskManager.createNewTask(lstToken, 0);
    }
    
    function testTaskManagerCreateTaskZeroAddress() public {
        vm.expectRevert("YieldSyncTaskManager: invalid LST token");
        taskManager.createNewTask(address(0), 400);
    }
    
    function testTaskManagerCreateTaskExtremeYield() public {
        address lstToken = makeAddr("lstToken");
        vm.expectRevert("YieldSyncTaskManager: invalid required yield");
        taskManager.createNewTask(lstToken, type(uint256).max);
    }
    
    function testTaskManagerMultipleResponsesSameTask() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        bytes memory signature = "mock_signature";
        
        // First response
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, 420, signature);
        
        // Second response from same operator should succeed (update)
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, 430, signature);
    }
    
    function testTaskManagerResponseFromMultipleOperators() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        bytes memory signature = "mock_signature";
        address operator2 = makeAddr("operator2");
        
        // Response from first operator
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, 420, signature);
        
        // Response from second operator
        vm.prank(operator2);
        taskManager.respondToTask(taskIndex, 430, signature);
        
        // Both responses should exist
        (, , bool exists1) = taskManager.getResponseInfo(taskIndex, operator);
        (, , bool exists2) = taskManager.getResponseInfo(taskIndex, operator2);
        assertTrue(exists1);
        assertTrue(exists2);
    }
    
    function testTaskManagerExtremeYieldResponse() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 extremeYield = 50000; // 500%
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        vm.expectRevert("YieldSyncTaskManager: invalid yield rate");
        taskManager.respondToTask(taskIndex, extremeYield, signature);
    }
    
    function testTaskManagerBoundaryYieldResponse() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 boundaryYield = 10000; // 100% - max allowed
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, boundaryYield, signature);
        
        (uint256 responseYield, , bool exists) = taskManager.getResponseInfo(taskIndex, operator);
        assertEq(responseYield, boundaryYield);
        assertTrue(exists);
    }
    
    function testTaskManagerVeryLargeSignature() public {
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        
        // Create very large signature
        bytes memory largeSignature = new bytes(1000);
        for (uint i = 0; i < 1000; i++) {
            largeSignature[i] = bytes1(uint8(i % 256));
        }
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, largeSignature);
    }
    
    function testTaskManagerVeryLargeEvidence() public {
        // Create and respond to task first
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Create very large evidence
        bytes memory largeEvidence = new bytes(1000);
        for (uint i = 0; i < 1000; i++) {
            largeEvidence[i] = bytes1(uint8(i % 256));
        }
        
        address challenger = makeAddr("challenger");
        vm.prank(challenger);
        taskManager.challengeResponse(taskIndex, operator, largeEvidence);
    }
    
    function testTaskManagerTaskIndexOverflow() public {
        // This test would require creating many tasks to test overflow
        // For now, we'll test the edge case of max task index
        uint32 maxTaskIndex = type(uint32).max;
        
        (address token, uint256 yield, uint32 blockNumber, bool exists) = 
            taskManager.getTaskInfo(maxTaskIndex);
        assertFalse(exists); // Should not exist
    }
    
    function testTaskManagerChallengeNonExistentOperator() public {
        // Create and respond to task
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Challenge response from non-existent operator
        bytes memory evidence = "fraud_evidence";
        address challenger = makeAddr("challenger");
        address nonExistentOperator = makeAddr("nonExistentOperator");
        
        vm.prank(challenger);
        vm.expectRevert("YieldSyncTaskManager: no response to challenge");
        taskManager.challengeResponse(taskIndex, nonExistentOperator, evidence);
    }
    
    function testTaskManagerSelfChallenge() public {
        // Create and respond to task
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Operator challenges their own response
        bytes memory evidence = "self_fraud_evidence";
        
        vm.prank(operator);
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
    
    function testTaskManagerMultipleChallengesOneResponse() public {
        // Create and respond to task
        address lstToken = makeAddr("lstToken");
        taskManager.createNewTask(lstToken, 400);
        
        uint32 taskIndex = 1;
        uint256 yieldRate = 420;
        bytes memory signature = "mock_signature";
        
        vm.prank(operator);
        taskManager.respondToTask(taskIndex, yieldRate, signature);
        
        // Multiple challengers challenge the same response
        bytes memory evidence = "fraud_evidence";
        address challenger1 = makeAddr("challenger1");
        address challenger2 = makeAddr("challenger2");
        
        vm.prank(challenger1);
        taskManager.challengeResponse(taskIndex, operator, evidence);
        
        vm.prank(challenger2);
        taskManager.challengeResponse(taskIndex, operator, evidence);
    }
}